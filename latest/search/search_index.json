{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The FDO project is developing an implementation of the FIDO Device Onboard Specification by the FIDO Alliance. The FDO PRI is a reference implementation of the FDO Specification, and also implements the service modules required to exercise the complete system: Device, Manufacturer, Rendezvous Server, and Owner. The FDO Client SDK is a C-based implementation of the Device component defined in FIDO Device Onboard (FDO) Specification. The Implementation Reference includes different guides for integrating FDO components for various use-cases. See the release notes for a summary of features and capabilities implemented (or not) in different releases. Project Repositories \u00b6 Component Source Repository Client SDK https://github.com/secure-device-onboard/client-sdk-fidoiot Protocol Reference Implementation https://github.com/secure-device-onboard/pri-fidoiot EPID Verification Service https://github.com/secure-device-onboard/epid-verification-service CI Test https://github.com/secure-device-onboard/test-fidoiot","title":"Home"},{"location":"#project-repositories","text":"Component Source Repository Client SDK https://github.com/secure-device-onboard/client-sdk-fidoiot Protocol Reference Implementation https://github.com/secure-device-onboard/pri-fidoiot EPID Verification Service https://github.com/secure-device-onboard/epid-verification-service CI Test https://github.com/secure-device-onboard/test-fidoiot","title":"Project Repositories"},{"location":"community/","text":"Community \u00b6 Welcome to the Secure Device Onboard community. Secure Device Onboard is an open source project sponsored by LF Edge . Community practices are documented at the Secure Device Onboard wiki . For details, refer to the following topics: How to contribute Joining the discussion and getting help Project policies Reporting issues","title":"Community"},{"location":"community/#community","text":"Welcome to the Secure Device Onboard community. Secure Device Onboard is an open source project sponsored by LF Edge . Community practices are documented at the Secure Device Onboard wiki . For details, refer to the following topics: How to contribute Joining the discussion and getting help Project policies Reporting issues","title":"Community"},{"location":"installation/","text":"Installation Guide \u00b6 This document can be used as a quick start guide to setup the development environment. Please review the system requirements listed below before moving forward with the SDO installation and deployment. System Requirements \u00b6 Component Recommended Operating System Ubuntu* 20.04 / Windows* 10 Docker* Engine 18.09 Docker* Compose 1.21.2 Maven* 3.5.4 Java 11 Haveged - Docker* Installation \u00b6 1 . Removing the older versions of Docker*. If these are installed, uninstall them: sudo apt-get remove docker docker-engine docker.io containerd runc 2 . Update the apt package index and install packages to allow apt to use a repository over HTTPS: sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release Note If you are working behind a proxy, ensure to set proper proxy variables. 3 . Add official GPG key for Docker*: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 4 . Use the following command to set up the stable repository. echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 5 . Update the apt package index and install the Docker* Engine 18.09 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 6 . Verify that Docker* Engine is installed correctly by running the hello-world image. sudo docker run hello-world Running the Docker* Behind a Proxy \u00b6 To run the Docker* system behind a proxy server, the configuration is done by the following steps: 1 . Directory docker.service.d is to be created in systemd directory as shown below. mkdir -p /etc/systemd/system/docker.service.d 2 . For HTTP proxy, create a file http-proxy.conf in the above created directory and add the following content to this file. [Service] Environment=\"HTTP_PROXY=<Proxy IP/URL:Port>\" 3 . For HTTPS proxy, create a file https-proxy.conf in the above created directory and add the following content to this file. [Service] Environment=\"HTTPS_PROXY=<Proxy IP/URL:Port>\" 4 . Next, create a directory named .docker in the user home path ( ~/ ) and create a file named config.json if not present, add the following content. { \"proxies\": { \"default\": { \"httpProxy\": \"<Proxy IP/URL:Port>\", \"httpsProxy\": \"<Proxy IP/URL:Port>\" } } } 5 . After configuring the above, the Docker* service needs to be restarted. sudo systemctl daemon-reload sudo systemctl restart docker 6 . To ensure that the proxies are set successfully, run the following command sudo systemctl show --property Environment docker 7 . SDO Docker* FAQs Docker Time Synchronization Issue while building Ubuntu 20 docker image from an Ubuntu* 18 machine. Refer Failure in device onboarding due to the inaccessibility of internet (while running Docker* behind a proxy network). Refer Docker* Compose Installation \u00b6 To install a specific version of Docker* Compose (for example 1.21.2 ) follow these steps: 1 . Download the specific version (1.21.2) of Docker* Compose. sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/bin/docker-compose 2 . To apply executable permissions, run the following command. sudo chmod +x /usr/bin/docker-compose 3 . To ensure that the required version is installed, run docker-compose --version command Other Development Tools \u00b6 1 . To install OpenJDK* sudo apt install openjdk-11-jdk-headless 2 . To install Maven* sudo apt install maven 3 . To install Haveged sudo apt install haveged To set Correct System Time \u00b6 sudo date -s \"$(wget -qSO- --max-redirect=0 google.com 2>&1 | grep Date: | cut -d' ' -f5-8)Z\" Ensure that the system time is correct, else you will receive the certificate expiration error. Change Google* domain according to your location. References \u00b6 Docker-installation-methods Docker-compose-installation Setting-proxy-for-docker * represents proprietary software products. FDO claims no rights over the mentioned software products. Use them at your own discretion.","title":"Installation Guide"},{"location":"installation/#installation-guide","text":"This document can be used as a quick start guide to setup the development environment. Please review the system requirements listed below before moving forward with the SDO installation and deployment.","title":"Installation Guide"},{"location":"installation/#system-requirements","text":"Component Recommended Operating System Ubuntu* 20.04 / Windows* 10 Docker* Engine 18.09 Docker* Compose 1.21.2 Maven* 3.5.4 Java 11 Haveged -","title":"System Requirements"},{"location":"installation/#docker-installation","text":"1 . Removing the older versions of Docker*. If these are installed, uninstall them: sudo apt-get remove docker docker-engine docker.io containerd runc 2 . Update the apt package index and install packages to allow apt to use a repository over HTTPS: sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release Note If you are working behind a proxy, ensure to set proper proxy variables. 3 . Add official GPG key for Docker*: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 4 . Use the following command to set up the stable repository. echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 5 . Update the apt package index and install the Docker* Engine 18.09 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 6 . Verify that Docker* Engine is installed correctly by running the hello-world image. sudo docker run hello-world","title":"Docker* Installation"},{"location":"installation/#running-the-docker-behind-a-proxy","text":"To run the Docker* system behind a proxy server, the configuration is done by the following steps: 1 . Directory docker.service.d is to be created in systemd directory as shown below. mkdir -p /etc/systemd/system/docker.service.d 2 . For HTTP proxy, create a file http-proxy.conf in the above created directory and add the following content to this file. [Service] Environment=\"HTTP_PROXY=<Proxy IP/URL:Port>\" 3 . For HTTPS proxy, create a file https-proxy.conf in the above created directory and add the following content to this file. [Service] Environment=\"HTTPS_PROXY=<Proxy IP/URL:Port>\" 4 . Next, create a directory named .docker in the user home path ( ~/ ) and create a file named config.json if not present, add the following content. { \"proxies\": { \"default\": { \"httpProxy\": \"<Proxy IP/URL:Port>\", \"httpsProxy\": \"<Proxy IP/URL:Port>\" } } } 5 . After configuring the above, the Docker* service needs to be restarted. sudo systemctl daemon-reload sudo systemctl restart docker 6 . To ensure that the proxies are set successfully, run the following command sudo systemctl show --property Environment docker 7 . SDO Docker* FAQs Docker Time Synchronization Issue while building Ubuntu 20 docker image from an Ubuntu* 18 machine. Refer Failure in device onboarding due to the inaccessibility of internet (while running Docker* behind a proxy network). Refer","title":"Running the Docker* Behind a Proxy"},{"location":"installation/#docker-compose-installation","text":"To install a specific version of Docker* Compose (for example 1.21.2 ) follow these steps: 1 . Download the specific version (1.21.2) of Docker* Compose. sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/bin/docker-compose 2 . To apply executable permissions, run the following command. sudo chmod +x /usr/bin/docker-compose 3 . To ensure that the required version is installed, run docker-compose --version command","title":"Docker* Compose Installation"},{"location":"installation/#other-development-tools","text":"1 . To install OpenJDK* sudo apt install openjdk-11-jdk-headless 2 . To install Maven* sudo apt install maven 3 . To install Haveged sudo apt install haveged","title":"Other Development Tools"},{"location":"installation/#to-set-correct-system-time","text":"sudo date -s \"$(wget -qSO- --max-redirect=0 google.com 2>&1 | grep Date: | cut -d' ' -f5-8)Z\" Ensure that the system time is correct, else you will receive the certificate expiration error. Change Google* domain according to your location.","title":"To set Correct System Time"},{"location":"installation/#references","text":"Docker-installation-methods Docker-compose-installation Setting-proxy-for-docker * represents proprietary software products. FDO claims no rights over the mentioned software products. Use them at your own discretion.","title":"References"},{"location":"protocol-specification/","text":"Introduction \u00b6 The FIDO Device Onboard (FDO) Specification proposed standard is published at https://fidoalliance.org/specs/FDO/fido-device-onboard-v1.0-ps-20210323/","title":"Protocol Specification"},{"location":"protocol-specification/#introduction","text":"The FIDO Device Onboard (FDO) Specification proposed standard is published at https://fidoalliance.org/specs/FDO/fido-device-onboard-v1.0-ps-20210323/","title":"Introduction"},{"location":"reference/","text":"Description of different terminologies used in the documentation \u00b6 Term Description","title":"Reference"},{"location":"reference/#description-of-different-terminologies-used-in-the-documentation","text":"Term Description","title":"Description of different terminologies used in the documentation"},{"location":"releases/","text":"Releases \u00b6 The releases for implementation of FIDO Device Onboard specification are published on GitHub. Following list provides details about all the past releases. Current Release \u00b6 Release v0.5.0 Past Releases \u00b6 Release v0.3.0","title":"Releases"},{"location":"releases/#releases","text":"The releases for implementation of FIDO Device Onboard specification are published on GitHub. Following list provides details about all the past releases.","title":"Releases"},{"location":"releases/#current-release","text":"Release v0.5.0","title":"Current Release"},{"location":"releases/#past-releases","text":"Release v0.3.0","title":"Past Releases"},{"location":"security-best-practices/","text":"Needs to be updated as per FDO Introduction \u00b6 This document provides recommendations and best practices for all components of Secure Device Onboard. The intended audience includes anyone enabling Secure Device Onboard, such as device manufacturers, distributors, system integrators, IoT platform management service providers, and installers. Chapter\u202f2.0 describes security requirements and best practices that should be applied throughout the entire supply chain. Subsequent chapters describe security requirements and best practices that impact only the functionality or role of the titled chapter. Requirements that affect more than one but not all roles are listed in the chapter for each role. Document Terminology \u00b6 The document uses terminology from IETF requirements language (see RFC2119). \"SHALL\" means that the definition is an absolute requirement of the specification. \"SHALL NOT\" means that the definition is an absolute prohibition of the specification. \u201cSHOULD\u201d or the adjective \"RECOMMENDED\" means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course. \u201cSHOULD NOT\u201d or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label. \u201cMAY\u201d or the adjective \"OPTIONAL\" means that an item is truly optional. One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option SHALL be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option SHALL be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides). The terms MUST and MUST NOT are not used throughout this document. Terminology and Assets \u00b6 Secure Device Onboard functions to cause a Secure Device Onboard Device to be onboarded to a Secure Device Onboard Owner. The Secure Device Onboard Device is typically a headless computer, such as an Internet of Things (IoT) gateway, a small computer (MCU or MCP) with sensors, sometimes called an IoT Sensor, a small computer with an actuator, or some combination of the three. The Secure Device Onboard Owner is a controlling computer, typically in a cloud or operations center, that controls many such devices, checking their function, turning them on or off, collecting their data, or supplying them with instructions. The \u201conboard\u201d process is to take a device and provision into it secret information and associated information, so that the device can accept the remote control of the Secure Device Onboard Owner\u2019s computer. Examples of secret information are cryptographic keys, tokens, or passwords. Examples of associated information are: cryptographic certificates, IP addresses, software data or modules. Secure Device Onboard allows many different kinds of provisioning to happen between Secure Device Onboard Owners and Secure Device Onboard Devices. We use the term \u201conboard\u201d to denote a process where Secure Device Onboard assists a customer site to provision devices for itself, rather than mandating a specific \u201cone size fits all\u201d provisioning process. Indeed, Secure Device Onboard permits the customer to change provisioning mechanisms while a product is in the field, allowing security measures to be tuned continuously. The Ownership Voucher acts as a \u201cticket\u201d to allow the Secure Device Onboard Owner to run Secure Device Onboard successfully. It contains digital signatures that are generated by the Device Manufacturer and Supply Chain Stakeholders. The Secure Device Onboard Owner, Device, Device Manufacturer, and Supply Chain Stakeholders must protect specific assets to perform the onboarding task. It is the task of the Secure Device Onboard Device manufacturer and the Secure Device Onboard Owner to protect their own assets. The following table lists common assets, what they are used for, and why they should be protected. Protections are: Confidentiality: this asset is a secret, and revealing it to an attacker can cause Secure Device Onboard to fail. Availability: this asset must be available to allow Secure Device Onboard to function. Integrity: this asset must not be modified, or Secure Device Onboard will not function properly. Asset Where Used For Protection Required (Confidentiality, Availability, Integrity) Why to Protect GUID Device, Owner Identifying an Secure Device Onboard Device before it is onboarded. A, I The GUID allows a given Device to align with a given Owner, via the Ownership Voucher Intel \u00ae EPID signing key Device Proof from Device to Owner that the Device has a particular GUID. Often used as hardware root of trust. C, A, I Device is rejected unless the EPID signature is correct and the EPID group is trusted Intel \u00ae EPID Group ID Device, Owner A (large) number that identifies EPID keys within a specific product A, I Device proves it is a member of the group using the EPID signature; Owner must confirm that the group\u2019s associated product is acceptable Ownership Voucher Extension (OVE) key pair, private key Device Manufacturer, Supply Chain Stakeholders Intermediate signatures in OVE C, A, I Used to create a chain of signatures from manufacture to onboarding Secure Device Onboard Owner \u2013 Signing key pair, private key Owner Signing protocol operations with Rendezvous Service and Device C, A, I Used to prove Owner identity (see Secure Device Onboard Owner private key) Network between Manufacturing Station and device being initialized Manufacturer Preparing the device for Secure Device Onboard C, A, I Secure Device Onboard provisioning of initial credentials requires a trusted network environment. Attacker can steal or modify credentials and interfere with Secure Device Onboard. Ownership Credential (contains GUID, HMAC secret and other credentials) Device GUID and other credentials that allow a Device to perform Secure Device Onboard A, I (HMAC secret: C) Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Ownership Credential: HMAC Secret Device Secret value used to ensure that that Ownership Voucher is bound to the Device. Stored in the Device during manufacturing, and never revealed. C, A, I Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Manufacturing Credential Device Additional credentials that identify the manufacturer of the Device A, I Do not affect Secure Device Onboard performance, but cause a customer confusion if modified. Ownership Voucher (contains GUID) Manufacturer \u00e0 Supply Chain Stakeholders \u00e0 Owner Identifies the Secure Device Onboard Owner to the Secure Device Onboard Device. Created during manufacturing, augmented by Supply Chain Stakeholders, and finally used by the Secure Device Onboard Owner A, I Acts as a \u201cticket\u201d for the Secure Device Onboard Owner to take Ownership. Secure Device Onboard will not function properly if it is lost or corrupted. End-to-End Flow \u00b6 The Secure Device Onboard end-to-end flow is illustrated in the picture below. Figure\u202f1.End-to-End Flow Player Contributions Secure Device Onboard-Specific Function Security Responsibilities ODM / OEM Manufactures Devices Enable each device with Secure Device Onboard by executing Device Initialization (DI). DI creates the initial Ownership Voucher. Create correct Secure Device Onboard credentials and store securely in Device. Associate Device with correct Ownership Voucher (For example, via the GUID) Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ownership Voucher Extension Receive the Ownership Voucher from the previous supply chain stakeholder. Extend the Ownership Voucher to the next stakeholder as the device is shipped. Send the extended Ownership Voucher to the next stakeholder. Maintain its own Owner key pair (private key must be a secret!) Receive and verify the public key for the Owner key pair of the next Supply Chain Stakeholder1 Extend the Ownership Voucher to the correct public key Deliver the correct Ownership Voucher for the Device shipped Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ensure integrity of physical device. This is needed because automatic provisioning mechanisms (Secure Device Onboard or other) make it easier for a rogue device that is substituted to be accepted in the network No Secure Device Onboard specific function Take measures to ensure that the correct devices are installed. Ensure that the devices have not been tampered with (open boxes, broken seals). IoT Platform Service Provider Ownership Voucher Registration Receive the Ownership Voucher from the previous supply chain stakeholder. Register the Ownership Voucher with the Intel Rendezvous Service. Verify that the Device Certificate (in case of ECDSA based device keys) in Ownership Voucher comes from a trusted source (system distributor or manufacturer). The Root CA or intermediate CA in the Device certificate should be trusted Register to the correct Rendezvous Service and provide the right host/IP address for IoT Platform during registration (TO0 protocol) Use the private key corresponding to the last public key in Ownership Voucher to sign the messages in TO0 protocol As a supply chain stakeholder: Maintain the Secure Device Onboard Owner signing key pair (private key must be a secret!) System Installer Install Device, Power On Provide Internet connectivity (natively or via helper device). Identify the deployment physical location specifics to the Owner, so the Device can be operated usefully Avoid DoS attacks on the network during Secure Device Onboard IoT Platform Service Provider Device onboarding Runs Secure Device Onboard TO2 protocol Aids in authentication with device by signing the messages with its Owner private key Sends the IoT application specific agents, data and credentials to the device using Secure Device Onboard Provision the device with the right set of application specific credentials for the IoT agent on the device to securely connect and communicate with the IoT platform Configure the firewall and other security properties of the device during onboarding Reconfigure the device with the new Owner key, GUID and Rendezvous Info Maintain the new Owner key for the device and keep the private key a secret Cryptographic Strength \u00b6 Progress in the fields of computing and cryptography have caused cryptographic strength requirements to increase over time. A cryptographic key that was deployed securely some years ago can be broken today, based on faster and more computers and better techniques. In particular, the emerging field of quantum cryptography provides new tools that can compromise cryptographic keys. Cryptography deployed in Secure Device Onboard meets or exceeds current security requirements expected for the life of this product. Customers are encouraged to track developments in quantum cryptography in order to make intelligent assessments as to their cryptographic requirements on an ongoing basis. Customers are also encouraged to watch for security notifications that indicate new emerging risks. End-to-End Security Requirements \u00b6 This chapter addresses security requirements that are NOT specific to a particular component or role in the entire supply chain. Key Pair\u2019s Private Key Protection \u00b6 The private keys of all key pairs shall be protected throughout the entire supply chain, from the ODM to Cloud Service Provider. At a minimum, all private keys shall be protected at rest, for example, by storing them only on an encrypted file system, hardware security modules (HSM) or a distributed storage vault. Cryptographic keys require strong security at runtime, because they may be exposed to use by software. The Secure Device Onboard Reseller Tool is specifically designed so that it can be deployed with sufficient security for supply chain stakeholders to protect key pair private keys. However, the deployment must still ensure that the hardware and software are deployed safely, as below. At-Rest Protection \u00b6 At-rest protection means private keys are protected on disk or in the database but held in clear text in memory to perform signing operations. Storing the key in a file system of a machine requires careful procedural controls to ensure that the entire machine is protected from physical and virtual access. When backup procedures of the file system or database are in place, the same procedural controls shall be applied to the backup medium, especially when the medium is Internet accessible (for example, AWS S3 buckets, Google Drive ). Backup of systems through cloud services (for example, Carbonite , BackBlaze ) need additional considerations that might require case-by-case negotiations with the service provider. Memory isolation is therefore important to prevent leakage of keys across applications, containers, or virtual machines. Private key shall never be stored in plaintext Private key shall only be stored on encrypted disk or databases, or in hardware security based storages such as HSM or TPM If the private key is stored in a file or database, its encryption should be anchored in a hardware-based root of trust, such as a trusted platform module (TPM) or crypto tokens, to prevent theft of keys not in use. Applications performing the signing operations should only run on dedicated systems that are not being used for general compute to reduce the risk of side-channel attacks to obtain the keys. The system on which the private key is stored should be physically protected from theft. Runtime Protection \u00b6 To prevent private key exposure even at runtime, it is recommended to use hardware to isolate and protect keys and key operations from other parts of the system. Crypto tokens, hardware security modules (HSMs), trusted platform modules (TPMs), or processor-assisted technologies, such as Intel \u00ae Platform Trust Technology (Intel \u00ae PTT) or Intel \u00ae Software Guard Extensions (Intel \u00ae SGX), can provide these capabilities. A secure element that is physically affixed to the platform ties keys and the platform together and makes key theft visually evident since the platform will be missing. Runtime environment (including the applications and UI) that is used to access the private key for signing operation shall be restricted to only trusted users and applications. It is highly recommended to log the usage of the key such that it can be audited later in time. Customers must take care, that such cryptographic hardware is only as secure as its deployment. Even a security token that can never export a private key can be exploited if it is physically stolen from the workplace. ODM/OEM \u2014 Device Manufacturing \u00b6 This chapter addresses the manufacturing of devices, such as gateways or hardware appliances. Manufacturing Station \u00b6 The execution of the device initialization handshake is a security sensitive operation. Due to the nature of the handshake process, trust must be provided through physical isolation such as running the manufacturing station environment on a dedicated system and connecting the device over a dedicated network. This is also common best practice for other manufacturing operations such as initial flashing of the BIOS. Manufacturer\u2019s Public Key \u00b6 The Manufacturing Station requires holding the manufacturer\u2019s public key. The hash of this key is provisioned in the device during manufacturing and represents the private key that is trusted by the device as an Owner (first owner). This key is also associated with the private key residing in the first instance of the Reseller Tool, typically deployed in the manufacturer\u2019s data center. The public key shall be protected from malicious modification or replacement. During device initialization, an Ownership Voucher containing the first owner\u2019s public key is created by the Manufacturing Station and sent to manufacturer\u2019s Reseller Tool \u2014 the first Reseller Tool in the supply chain. The Manufacturing Station must be protected to prevent an adversary from performing a man-in-the-middle attack and obtaining the device\u2019s true ownership voucher while the Manufacturing Station sends an incorrect but valid ownership voucher to Reseller Tool. The figure above illustrates the relationship between the Reseller Tool and Manufacturing Station. Secure Device Onboard Database \u00b6 Secure Device Onboard database contains critical information such as the Device GUID and Rendezvous Info that is provisioned by the Manufacturer\u2019s tool in the device during DI. In addition, it contains the Ownership Vouchers produced during manufacturing. This is not confidential information from Secure Device Onboard security perspective but have business significance. The Secure Device Onboard database shall be protected from access from unauthorized personnel and applications. Device Initialization Network (DI Network) \u00b6 The data that is exchanged between the device and manufacturing station during DI protocol shall be protected from modification. Otherwise the device and Ownership Voucher may have incorrect Secure Device Onboard data, which can cause Secure Device Onboard to fail or device to malfunction during installation. Therefore, the DI network between devices and the Manufacturing Station should be used for the sole purpose of providing the device with the software necessary to perform DI (for example, PXE boot) and the DI protocol handshake. Device Manufacturing with Intel \u00ae DAL \u00ae -based Platforms \u00b6 Hardware platforms using Intel processors such as Intel Atom \u00ae or Intel \u00ae Core\u2122 have a secure DAL \u00ae (Dynamic Application Loader) environment which are all Intel \u00ae EPID enabled and do not require special steps to provision EPID signing keys. As they are also able to run generic operating systems such as Linux*, the device is capable of running a complete application that triggers the device initialization handshake procedure between the to-be-initialized device and a manufacturing station over a network connection. During the DI protocol, the HMAC secret is allocated within the DAL environment of the device. The HMAC used in the Ownership Voucher is generated by the device and transmitted to the Manufacturing Station. The HMAC secret is never revealed, and automatically maintained securely in the device. Other credentials on such as GUID, manufacturer\u2019s public key hash, Rendezvous Info are also protected in a secure storage and runtime environment provided by DAL \u00ae . This is all handled by the Secure Device Onboard DAL applet provided by Intel. Device Manufacturing with Non-Intel or Non-DAL \u00ae Platforms \u00b6 Protection (C, A, I) of Device ECDSA key \u00b6 The ECDSA key must be protected within the Device so that it can be used by the Device, but not revealed outside the Device. Various kinds of devices have different mechanisms for performing this. These include: A secure element or TPM might store the key and perform ECDSA operations The device may have a secure storage area (such as RPMB protected by secure TrustZone) that is only readable on chip. Sometimes this requires that JTAG be disabled The device may have a secure boot with an individual secure boot key, known only to the device. Device secrets, such as the ECDSA key can be encrypted using the secure boot key or its derivation. Some combination of these concepts Encryption alone does not protect the integrity of the ECDSA key. A signature or HMAC mechanism is also needed. Again, specific mechanisms vary by hardware design. Protection (C, A, I) of HMAC secret \u00b6 HMAC secret should be protected in the same way as the Device key. Protection (AI) of other Secure Device Onboard Credentials \u00b6 Other Secure Device Onboard credentials provisioned on the device such as Manufacturer\u2019s Public Key Hash, GUID and Rendezvous Info do not need to be confidential. However, to ensure their integrity, a signature or HMAC (with a protected secret) is needed. Encryption of the credentials may be used if convenient, but encryption by itself does not ensure integrity. These credentials must be available to the device or Secure Device Onboard will fail. Some devices have internal flash regions that cannot be reprogrammed by an attacker, which can improve availability. Secure elements may also have this property in their key protection areas. An OTP memory can contribute to availability and/or integrity of Secure Device Onboard credentials. However, since OTP memory is limited in size, this might limit the ability to use Secure Device Onboard in its \u201cresale\u201d mode. It is acceptable for a Secure Device Onboard Device to be limited in the number of times it can run Secure Device Onboard. In some cases, this might be done to improve device security, by removing the Secure Device Onboard credentials as an attack surface. Supply Chain \u2014 Ownership Voucher Extension \u00b6 Supply chain members extend Ownership Vouchers. Extension means that the next logical owner\u2019s public key is appended to the current ownership voucher and then signed with the current owner\u2019s private key. For a chain of keys to be valid, the private key\u2019s associated public key was appended in the same fashion by the previous owner. Each key pair in the chain is called an Ownership Voucher Extension (OVE) key pair. Ownership Voucher Extension (OVE) Environment \u00b6 The OVE environment shall be considered sensitive and part of the business-critical infrastructure. Adequate protection such as data-center access controls, firewalling, multi-tier deployment, and DMZ isolation techniques shall be applied. All RESTful API access SHALL be secured using TLS 1.2 and above. All RESTful API access SHOULD be secured using TLS 1.3 and above. All RESTful API access SHOULD be firewalled and load-balanced. Too many subsequent erroneous requests SHOULD lead to request throttling to reduce DoS attacks. Database backends SHOULD be deployed on separate servers in separate zones. Database connections SHOULD be secured using TLS (have \u201cuseSSL=true&requireSSL=true\" in the connection string). All implementation should use the Secure Device Onboard Reseller Tool to manage Ownership Vouchers, so that rules for Ownership Vouchers are maintained automatically: Ownership Voucher should be extended using the same key type and size as the original Owner public key in the Ownership Voucher header Supply chain stakeholders shall use Ownership Vouchers only to extend for the next Owner and shall not use them to run Secure Device Onboard TO protocols. Key Lifetime Agreement \u00b6 The lifetime of the OVE key pair used for extending an Ownership Voucher SHALL be limited to a reasonable duration or number of ownership extensions. From a supply chain perspective, sending the OVE\u2019s public key to the supplier (along with the order) and receiving one extended Ownership Voucher per ordered device is tightly coupled to the purchase order. The supplier knows how many Ownership Vouchers will be extended for a particular purchase order. The private key shall be kept until the device is purchased by the next owner or the device is retired. The key is needed to extend the Ownership Voucher to the next Owner. Service Provider \u2014 Owner Implementation \u00b6 The Secure Device Onboard Owner Implementation is responsible for receiving the final Ownership Voucher in the supply chain and issuing the TO0 protocol to the Rendezvous Server. The owner implementation is typically tightly integrated into the IoT Platform Management service provider\u2019s environment, therefore developed, built, and managed by the provider. It is also the point where the device is logically associated with a particular Management service account. The owner implementation runs in a secured facility such as a data center. Owner Key Pair Usage \u00b6 The Management service administrator provides the public key to the previous entity in the supply chain. The associated private key is used during the TO0 protocol phase with the Rendezvous Server. Each service account should have individual key pairs. This allows the Management Service to differentiate incoming ownership vouchers by account and to refuse vouchers extended to the wrong account. Private keys shall be protected as mentioned in Section 2.1. If the private key is exposed, (a) adversary devices can be added to an account without authorization, (b) legitimate devices can be added to adversary accounts. Key pair retirement: Private keys have to be available for signing operations until all the associated Ownership Vouchers have been consumed using the TO2 protocol. The Owner may cycle keys so that new Ownership Vouchers use the newer keys, but the old keys are still needed for signing (in the TO0 and TO2 protocols) until all Ownership Vouchers that reference them are processed. Runtime Protection of Owner Signing Keys \u00b6 The recommendation is to protect owner signing keys using security hardware. However, in large-scale operations with a significant number of accounts, the number of available hardware-protected keys might be limited. In this case, a two-step process should be deployed. The private key corresponding to the public key exposed to the account owner for ownership extension is protected only at rest. The ownership vouchers extended to that public key are then extended to a second public key where the corresponding private key is located in an HSM. The HSM is used to perform the signing operation for the final TO0 process. Since steps 1 and 2 are performed in temporal proximity, it is exactly known how long the private key is needed since Ownership Vouchers are never extended to the associated public key without performing TO0. The two-step process allows simplified key management and rolling the HSM key pair at a regular basis. Installer Notes \u00b6 Secure Device Onboard simplifies the onboarding process by eliminating cumbersome manual provisioning. Such form of automation, however, also creates risks of attacks based on social engineering that should be mitigated by proper installation and verification practices. Verification of Authenticity of Devices \u00b6 Installers shall verify the origin of the devices to be installed. If a device\u2019s origin is not known and the device was exchanged, or tampered with between manufacturing and installation, an adversary can onboard a malicious Secure Device Onboard-enabled device in a target environment without much inside knowledge of the environment. After power-up, the Secure Device Onboard-enabled device would connect to the adversary\u2019s device management service and be under its control. Installation Complete Test \u00b6 The danger of introducing a rogue device into the customer\u2019s network is higher when automatic provisioning (including Secure Device Onboard) is used than when each device is manually configured. Under manual configuration, an attacker needs to compromise a device and a person to install it. Under automatic provisioning, the attacker needs only to compromise the device and fool a trusted person to install it. For example, the attacker can switch boxes. After the onboarding process has completed, the installer should verify that the device is under the control of the expected device management service. For example, by evaluating that the device\u2019s serial number shows up in the management console. Keeping a count of systems physically installed and systems newly seen at the management console is also useful. If the device does not report an onboarding error but cannot be verified in the Management service console, the device should not be left connected. Network Restrictions at Installation \u00b6 The following additional measures are useful to prevent a rogue device from successfully operating in a customer environment, and should be implemented whenever feasible: Network authentication for IoT devices. Secure Device Onboard itself may be used to configure the network authentication into trusted (\u201cnon-rogue\u201d) devices. When all devices must be authenticated to the local network in order to function, a rogue device may be unable to connect to its intended (rogue) manager and thus fail to exfiltrate data. Network security for IoT devices that prevents them from arbitrary connection to the Internet. In many cases, IoT devices need only connect to a few sites on the Internet (for example, for software update, device management, data upload). If network access can be restricted to these sites, a rogue device may be restricted from exfiltrating data. These measures overlap in their effectiveness. In some cases, one may be easier to implement than the other. For security measures, the best policy is to implement both; a belt and suspenders back each other up from embarrassing failures. IoT Security Practices, Implementation Notes \u00b6 Secure Device Onboard does not guarantee the security of an IoT device; it just gives a good start. For most of the lifetime of the device, it must secure itself. Indeed, a failure in device security may also allow Secure Device Onboard security to fail. The following best practices are needed to ensure that an IoT device securely implements Secure Device Onboard. In general, these are good security practices that are always recommended. Secure or Verified boot. Ensure that only the desired operating system will load, so expected OS protections are implemented as predicted. Secure the OS and the file system, using one of the many best practices guides available. Secure the Secure Device Onboard programs and data stored on the OS. Deploy the Secure Device Onboard Owner in a protected data-center type environment, where physical and login access is strictly controlled. Protect the keys for the Secure Device Onboard Owner using hardware security (HSM, TPM, and others). Use secure protocols to communicate with IoT devices, and using two-way authentication (from manager to IoT device and IoT device to manager). Use standard protocols (For example, TLS 1.3) and standard implementations, to benefit from the additional security reviews done on them Use the latest versions of these implementations and update them as new ones appear Secure programming practices must be used when implementing Secure Device Onboard components Care must be taken when implementing Secure Device Onboard only to implement the Secure Device Onboard protocols that are needed for this implementation. For example, do not enable the Secure Device Onboard Device protocols for an Secure Device Onboard Owner implementation. Never enable the Secure Device Onboard Device Initialize implementation other than on a Device in manufacturing. EPID revocation information must be updated in a timely manner by Secure Device Onboard Owners. When the Intel\u00ae EPID verification service is used (this is the default), this happens automatically. Secure Device Onboard Devices with a single Trusted Computing Base (no Trusted Execution Environment) must have all the EPID keys in EPID groups only associated with the same product (for example, all keys in EPID groups for a given toaster product, or a given industrial actuator, but no groups with products mixed inside of them). This security practice is useful because Secure Device Onboard EPID authentication is by group membership. If groups contain mixed products, an attacker who penetrates a less valued target (for example, the toaster) may leverage this effort toward a more valued target (for example, a factory with industrial controllers in it). The exception is when Secure Device Onboard is implemented in a trusted execution environment with hardware protection of its own, that is, a separate Trusted Compute Base. In this case, the EPID group may follow the Trusted Compute Base (TCB) for the Secure Device Onboard implementation, and the main execution environment (outside the Trusted Execution Environment) may span many products.","title":"Security Best Practices"},{"location":"security-best-practices/#introduction","text":"This document provides recommendations and best practices for all components of Secure Device Onboard. The intended audience includes anyone enabling Secure Device Onboard, such as device manufacturers, distributors, system integrators, IoT platform management service providers, and installers. Chapter\u202f2.0 describes security requirements and best practices that should be applied throughout the entire supply chain. Subsequent chapters describe security requirements and best practices that impact only the functionality or role of the titled chapter. Requirements that affect more than one but not all roles are listed in the chapter for each role.","title":"Introduction"},{"location":"security-best-practices/#document-terminology","text":"The document uses terminology from IETF requirements language (see RFC2119). \"SHALL\" means that the definition is an absolute requirement of the specification. \"SHALL NOT\" means that the definition is an absolute prohibition of the specification. \u201cSHOULD\u201d or the adjective \"RECOMMENDED\" means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course. \u201cSHOULD NOT\u201d or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label. \u201cMAY\u201d or the adjective \"OPTIONAL\" means that an item is truly optional. One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option SHALL be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option SHALL be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides). The terms MUST and MUST NOT are not used throughout this document.","title":"Document Terminology"},{"location":"security-best-practices/#terminology-and-assets","text":"Secure Device Onboard functions to cause a Secure Device Onboard Device to be onboarded to a Secure Device Onboard Owner. The Secure Device Onboard Device is typically a headless computer, such as an Internet of Things (IoT) gateway, a small computer (MCU or MCP) with sensors, sometimes called an IoT Sensor, a small computer with an actuator, or some combination of the three. The Secure Device Onboard Owner is a controlling computer, typically in a cloud or operations center, that controls many such devices, checking their function, turning them on or off, collecting their data, or supplying them with instructions. The \u201conboard\u201d process is to take a device and provision into it secret information and associated information, so that the device can accept the remote control of the Secure Device Onboard Owner\u2019s computer. Examples of secret information are cryptographic keys, tokens, or passwords. Examples of associated information are: cryptographic certificates, IP addresses, software data or modules. Secure Device Onboard allows many different kinds of provisioning to happen between Secure Device Onboard Owners and Secure Device Onboard Devices. We use the term \u201conboard\u201d to denote a process where Secure Device Onboard assists a customer site to provision devices for itself, rather than mandating a specific \u201cone size fits all\u201d provisioning process. Indeed, Secure Device Onboard permits the customer to change provisioning mechanisms while a product is in the field, allowing security measures to be tuned continuously. The Ownership Voucher acts as a \u201cticket\u201d to allow the Secure Device Onboard Owner to run Secure Device Onboard successfully. It contains digital signatures that are generated by the Device Manufacturer and Supply Chain Stakeholders. The Secure Device Onboard Owner, Device, Device Manufacturer, and Supply Chain Stakeholders must protect specific assets to perform the onboarding task. It is the task of the Secure Device Onboard Device manufacturer and the Secure Device Onboard Owner to protect their own assets. The following table lists common assets, what they are used for, and why they should be protected. Protections are: Confidentiality: this asset is a secret, and revealing it to an attacker can cause Secure Device Onboard to fail. Availability: this asset must be available to allow Secure Device Onboard to function. Integrity: this asset must not be modified, or Secure Device Onboard will not function properly. Asset Where Used For Protection Required (Confidentiality, Availability, Integrity) Why to Protect GUID Device, Owner Identifying an Secure Device Onboard Device before it is onboarded. A, I The GUID allows a given Device to align with a given Owner, via the Ownership Voucher Intel \u00ae EPID signing key Device Proof from Device to Owner that the Device has a particular GUID. Often used as hardware root of trust. C, A, I Device is rejected unless the EPID signature is correct and the EPID group is trusted Intel \u00ae EPID Group ID Device, Owner A (large) number that identifies EPID keys within a specific product A, I Device proves it is a member of the group using the EPID signature; Owner must confirm that the group\u2019s associated product is acceptable Ownership Voucher Extension (OVE) key pair, private key Device Manufacturer, Supply Chain Stakeholders Intermediate signatures in OVE C, A, I Used to create a chain of signatures from manufacture to onboarding Secure Device Onboard Owner \u2013 Signing key pair, private key Owner Signing protocol operations with Rendezvous Service and Device C, A, I Used to prove Owner identity (see Secure Device Onboard Owner private key) Network between Manufacturing Station and device being initialized Manufacturer Preparing the device for Secure Device Onboard C, A, I Secure Device Onboard provisioning of initial credentials requires a trusted network environment. Attacker can steal or modify credentials and interfere with Secure Device Onboard. Ownership Credential (contains GUID, HMAC secret and other credentials) Device GUID and other credentials that allow a Device to perform Secure Device Onboard A, I (HMAC secret: C) Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Ownership Credential: HMAC Secret Device Secret value used to ensure that that Ownership Voucher is bound to the Device. Stored in the Device during manufacturing, and never revealed. C, A, I Removing or invalidating these credentials will prevent a Device from performing Secure Device Onboard successfully Manufacturing Credential Device Additional credentials that identify the manufacturer of the Device A, I Do not affect Secure Device Onboard performance, but cause a customer confusion if modified. Ownership Voucher (contains GUID) Manufacturer \u00e0 Supply Chain Stakeholders \u00e0 Owner Identifies the Secure Device Onboard Owner to the Secure Device Onboard Device. Created during manufacturing, augmented by Supply Chain Stakeholders, and finally used by the Secure Device Onboard Owner A, I Acts as a \u201cticket\u201d for the Secure Device Onboard Owner to take Ownership. Secure Device Onboard will not function properly if it is lost or corrupted.","title":"Terminology and Assets"},{"location":"security-best-practices/#end-to-end-flow","text":"The Secure Device Onboard end-to-end flow is illustrated in the picture below. Figure\u202f1.End-to-End Flow Player Contributions Secure Device Onboard-Specific Function Security Responsibilities ODM / OEM Manufactures Devices Enable each device with Secure Device Onboard by executing Device Initialization (DI). DI creates the initial Ownership Voucher. Create correct Secure Device Onboard credentials and store securely in Device. Associate Device with correct Ownership Voucher (For example, via the GUID) Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ownership Voucher Extension Receive the Ownership Voucher from the previous supply chain stakeholder. Extend the Ownership Voucher to the next stakeholder as the device is shipped. Send the extended Ownership Voucher to the next stakeholder. Maintain its own Owner key pair (private key must be a secret!) Receive and verify the public key for the Owner key pair of the next Supply Chain Stakeholder1 Extend the Ownership Voucher to the correct public key Deliver the correct Ownership Voucher for the Device shipped Supply Chain Stakeholders: ODM / OEM, Distributor, Reseller, System Integrator Ensure integrity of physical device. This is needed because automatic provisioning mechanisms (Secure Device Onboard or other) make it easier for a rogue device that is substituted to be accepted in the network No Secure Device Onboard specific function Take measures to ensure that the correct devices are installed. Ensure that the devices have not been tampered with (open boxes, broken seals). IoT Platform Service Provider Ownership Voucher Registration Receive the Ownership Voucher from the previous supply chain stakeholder. Register the Ownership Voucher with the Intel Rendezvous Service. Verify that the Device Certificate (in case of ECDSA based device keys) in Ownership Voucher comes from a trusted source (system distributor or manufacturer). The Root CA or intermediate CA in the Device certificate should be trusted Register to the correct Rendezvous Service and provide the right host/IP address for IoT Platform during registration (TO0 protocol) Use the private key corresponding to the last public key in Ownership Voucher to sign the messages in TO0 protocol As a supply chain stakeholder: Maintain the Secure Device Onboard Owner signing key pair (private key must be a secret!) System Installer Install Device, Power On Provide Internet connectivity (natively or via helper device). Identify the deployment physical location specifics to the Owner, so the Device can be operated usefully Avoid DoS attacks on the network during Secure Device Onboard IoT Platform Service Provider Device onboarding Runs Secure Device Onboard TO2 protocol Aids in authentication with device by signing the messages with its Owner private key Sends the IoT application specific agents, data and credentials to the device using Secure Device Onboard Provision the device with the right set of application specific credentials for the IoT agent on the device to securely connect and communicate with the IoT platform Configure the firewall and other security properties of the device during onboarding Reconfigure the device with the new Owner key, GUID and Rendezvous Info Maintain the new Owner key for the device and keep the private key a secret","title":"End-to-End Flow"},{"location":"security-best-practices/#cryptographic-strength","text":"Progress in the fields of computing and cryptography have caused cryptographic strength requirements to increase over time. A cryptographic key that was deployed securely some years ago can be broken today, based on faster and more computers and better techniques. In particular, the emerging field of quantum cryptography provides new tools that can compromise cryptographic keys. Cryptography deployed in Secure Device Onboard meets or exceeds current security requirements expected for the life of this product. Customers are encouraged to track developments in quantum cryptography in order to make intelligent assessments as to their cryptographic requirements on an ongoing basis. Customers are also encouraged to watch for security notifications that indicate new emerging risks.","title":"Cryptographic Strength"},{"location":"security-best-practices/#end-to-end-security-requirements","text":"This chapter addresses security requirements that are NOT specific to a particular component or role in the entire supply chain.","title":"End-to-End Security Requirements"},{"location":"security-best-practices/#key-pairs-private-key-protection","text":"The private keys of all key pairs shall be protected throughout the entire supply chain, from the ODM to Cloud Service Provider. At a minimum, all private keys shall be protected at rest, for example, by storing them only on an encrypted file system, hardware security modules (HSM) or a distributed storage vault. Cryptographic keys require strong security at runtime, because they may be exposed to use by software. The Secure Device Onboard Reseller Tool is specifically designed so that it can be deployed with sufficient security for supply chain stakeholders to protect key pair private keys. However, the deployment must still ensure that the hardware and software are deployed safely, as below.","title":"Key Pair\u2019s Private Key Protection"},{"location":"security-best-practices/#at-rest-protection","text":"At-rest protection means private keys are protected on disk or in the database but held in clear text in memory to perform signing operations. Storing the key in a file system of a machine requires careful procedural controls to ensure that the entire machine is protected from physical and virtual access. When backup procedures of the file system or database are in place, the same procedural controls shall be applied to the backup medium, especially when the medium is Internet accessible (for example, AWS S3 buckets, Google Drive ). Backup of systems through cloud services (for example, Carbonite , BackBlaze ) need additional considerations that might require case-by-case negotiations with the service provider. Memory isolation is therefore important to prevent leakage of keys across applications, containers, or virtual machines. Private key shall never be stored in plaintext Private key shall only be stored on encrypted disk or databases, or in hardware security based storages such as HSM or TPM If the private key is stored in a file or database, its encryption should be anchored in a hardware-based root of trust, such as a trusted platform module (TPM) or crypto tokens, to prevent theft of keys not in use. Applications performing the signing operations should only run on dedicated systems that are not being used for general compute to reduce the risk of side-channel attacks to obtain the keys. The system on which the private key is stored should be physically protected from theft.","title":"At-Rest Protection"},{"location":"security-best-practices/#runtime-protection","text":"To prevent private key exposure even at runtime, it is recommended to use hardware to isolate and protect keys and key operations from other parts of the system. Crypto tokens, hardware security modules (HSMs), trusted platform modules (TPMs), or processor-assisted technologies, such as Intel \u00ae Platform Trust Technology (Intel \u00ae PTT) or Intel \u00ae Software Guard Extensions (Intel \u00ae SGX), can provide these capabilities. A secure element that is physically affixed to the platform ties keys and the platform together and makes key theft visually evident since the platform will be missing. Runtime environment (including the applications and UI) that is used to access the private key for signing operation shall be restricted to only trusted users and applications. It is highly recommended to log the usage of the key such that it can be audited later in time. Customers must take care, that such cryptographic hardware is only as secure as its deployment. Even a security token that can never export a private key can be exploited if it is physically stolen from the workplace.","title":"Runtime Protection"},{"location":"security-best-practices/#odmoem-device-manufacturing","text":"This chapter addresses the manufacturing of devices, such as gateways or hardware appliances.","title":"ODM/OEM \u2014 Device Manufacturing"},{"location":"security-best-practices/#manufacturing-station","text":"The execution of the device initialization handshake is a security sensitive operation. Due to the nature of the handshake process, trust must be provided through physical isolation such as running the manufacturing station environment on a dedicated system and connecting the device over a dedicated network. This is also common best practice for other manufacturing operations such as initial flashing of the BIOS.","title":"Manufacturing Station"},{"location":"security-best-practices/#manufacturers-public-key","text":"The Manufacturing Station requires holding the manufacturer\u2019s public key. The hash of this key is provisioned in the device during manufacturing and represents the private key that is trusted by the device as an Owner (first owner). This key is also associated with the private key residing in the first instance of the Reseller Tool, typically deployed in the manufacturer\u2019s data center. The public key shall be protected from malicious modification or replacement. During device initialization, an Ownership Voucher containing the first owner\u2019s public key is created by the Manufacturing Station and sent to manufacturer\u2019s Reseller Tool \u2014 the first Reseller Tool in the supply chain. The Manufacturing Station must be protected to prevent an adversary from performing a man-in-the-middle attack and obtaining the device\u2019s true ownership voucher while the Manufacturing Station sends an incorrect but valid ownership voucher to Reseller Tool. The figure above illustrates the relationship between the Reseller Tool and Manufacturing Station.","title":"Manufacturer\u2019s Public Key"},{"location":"security-best-practices/#secure-device-onboard-database","text":"Secure Device Onboard database contains critical information such as the Device GUID and Rendezvous Info that is provisioned by the Manufacturer\u2019s tool in the device during DI. In addition, it contains the Ownership Vouchers produced during manufacturing. This is not confidential information from Secure Device Onboard security perspective but have business significance. The Secure Device Onboard database shall be protected from access from unauthorized personnel and applications.","title":"Secure Device Onboard Database"},{"location":"security-best-practices/#device-initialization-network-di-network","text":"The data that is exchanged between the device and manufacturing station during DI protocol shall be protected from modification. Otherwise the device and Ownership Voucher may have incorrect Secure Device Onboard data, which can cause Secure Device Onboard to fail or device to malfunction during installation. Therefore, the DI network between devices and the Manufacturing Station should be used for the sole purpose of providing the device with the software necessary to perform DI (for example, PXE boot) and the DI protocol handshake.","title":"Device Initialization Network (DI Network)"},{"location":"security-best-practices/#device-manufacturing-with-intel-dal-based-platforms","text":"Hardware platforms using Intel processors such as Intel Atom \u00ae or Intel \u00ae Core\u2122 have a secure DAL \u00ae (Dynamic Application Loader) environment which are all Intel \u00ae EPID enabled and do not require special steps to provision EPID signing keys. As they are also able to run generic operating systems such as Linux*, the device is capable of running a complete application that triggers the device initialization handshake procedure between the to-be-initialized device and a manufacturing station over a network connection. During the DI protocol, the HMAC secret is allocated within the DAL environment of the device. The HMAC used in the Ownership Voucher is generated by the device and transmitted to the Manufacturing Station. The HMAC secret is never revealed, and automatically maintained securely in the device. Other credentials on such as GUID, manufacturer\u2019s public key hash, Rendezvous Info are also protected in a secure storage and runtime environment provided by DAL \u00ae . This is all handled by the Secure Device Onboard DAL applet provided by Intel.","title":"Device Manufacturing with Intel\u00ae DAL\u00ae-based Platforms"},{"location":"security-best-practices/#device-manufacturing-with-non-intel-or-non-dal-platforms","text":"","title":"Device Manufacturing with Non-Intel or Non-DAL\u00ae Platforms"},{"location":"security-best-practices/#protection-c-a-i-of-device-ecdsa-key","text":"The ECDSA key must be protected within the Device so that it can be used by the Device, but not revealed outside the Device. Various kinds of devices have different mechanisms for performing this. These include: A secure element or TPM might store the key and perform ECDSA operations The device may have a secure storage area (such as RPMB protected by secure TrustZone) that is only readable on chip. Sometimes this requires that JTAG be disabled The device may have a secure boot with an individual secure boot key, known only to the device. Device secrets, such as the ECDSA key can be encrypted using the secure boot key or its derivation. Some combination of these concepts Encryption alone does not protect the integrity of the ECDSA key. A signature or HMAC mechanism is also needed. Again, specific mechanisms vary by hardware design.","title":"Protection (C, A, I) of Device ECDSA key"},{"location":"security-best-practices/#protection-c-a-i-of-hmac-secret","text":"HMAC secret should be protected in the same way as the Device key.","title":"Protection (C, A, I) of HMAC secret"},{"location":"security-best-practices/#protection-ai-of-other-secure-device-onboard-credentials","text":"Other Secure Device Onboard credentials provisioned on the device such as Manufacturer\u2019s Public Key Hash, GUID and Rendezvous Info do not need to be confidential. However, to ensure their integrity, a signature or HMAC (with a protected secret) is needed. Encryption of the credentials may be used if convenient, but encryption by itself does not ensure integrity. These credentials must be available to the device or Secure Device Onboard will fail. Some devices have internal flash regions that cannot be reprogrammed by an attacker, which can improve availability. Secure elements may also have this property in their key protection areas. An OTP memory can contribute to availability and/or integrity of Secure Device Onboard credentials. However, since OTP memory is limited in size, this might limit the ability to use Secure Device Onboard in its \u201cresale\u201d mode. It is acceptable for a Secure Device Onboard Device to be limited in the number of times it can run Secure Device Onboard. In some cases, this might be done to improve device security, by removing the Secure Device Onboard credentials as an attack surface.","title":"Protection (AI) of other Secure Device Onboard Credentials"},{"location":"security-best-practices/#supply-chain-ownership-voucher-extension","text":"Supply chain members extend Ownership Vouchers. Extension means that the next logical owner\u2019s public key is appended to the current ownership voucher and then signed with the current owner\u2019s private key. For a chain of keys to be valid, the private key\u2019s associated public key was appended in the same fashion by the previous owner. Each key pair in the chain is called an Ownership Voucher Extension (OVE) key pair.","title":"Supply Chain \u2014 Ownership Voucher Extension"},{"location":"security-best-practices/#ownership-voucher-extension-ove-environment","text":"The OVE environment shall be considered sensitive and part of the business-critical infrastructure. Adequate protection such as data-center access controls, firewalling, multi-tier deployment, and DMZ isolation techniques shall be applied. All RESTful API access SHALL be secured using TLS 1.2 and above. All RESTful API access SHOULD be secured using TLS 1.3 and above. All RESTful API access SHOULD be firewalled and load-balanced. Too many subsequent erroneous requests SHOULD lead to request throttling to reduce DoS attacks. Database backends SHOULD be deployed on separate servers in separate zones. Database connections SHOULD be secured using TLS (have \u201cuseSSL=true&requireSSL=true\" in the connection string). All implementation should use the Secure Device Onboard Reseller Tool to manage Ownership Vouchers, so that rules for Ownership Vouchers are maintained automatically: Ownership Voucher should be extended using the same key type and size as the original Owner public key in the Ownership Voucher header Supply chain stakeholders shall use Ownership Vouchers only to extend for the next Owner and shall not use them to run Secure Device Onboard TO protocols.","title":"Ownership Voucher Extension (OVE) Environment"},{"location":"security-best-practices/#key-lifetime-agreement","text":"The lifetime of the OVE key pair used for extending an Ownership Voucher SHALL be limited to a reasonable duration or number of ownership extensions. From a supply chain perspective, sending the OVE\u2019s public key to the supplier (along with the order) and receiving one extended Ownership Voucher per ordered device is tightly coupled to the purchase order. The supplier knows how many Ownership Vouchers will be extended for a particular purchase order. The private key shall be kept until the device is purchased by the next owner or the device is retired. The key is needed to extend the Ownership Voucher to the next Owner.","title":"Key Lifetime Agreement"},{"location":"security-best-practices/#service-provider-owner-implementation","text":"The Secure Device Onboard Owner Implementation is responsible for receiving the final Ownership Voucher in the supply chain and issuing the TO0 protocol to the Rendezvous Server. The owner implementation is typically tightly integrated into the IoT Platform Management service provider\u2019s environment, therefore developed, built, and managed by the provider. It is also the point where the device is logically associated with a particular Management service account. The owner implementation runs in a secured facility such as a data center.","title":"Service Provider \u2014 Owner Implementation"},{"location":"security-best-practices/#owner-key-pair-usage","text":"The Management service administrator provides the public key to the previous entity in the supply chain. The associated private key is used during the TO0 protocol phase with the Rendezvous Server. Each service account should have individual key pairs. This allows the Management Service to differentiate incoming ownership vouchers by account and to refuse vouchers extended to the wrong account. Private keys shall be protected as mentioned in Section 2.1. If the private key is exposed, (a) adversary devices can be added to an account without authorization, (b) legitimate devices can be added to adversary accounts. Key pair retirement: Private keys have to be available for signing operations until all the associated Ownership Vouchers have been consumed using the TO2 protocol. The Owner may cycle keys so that new Ownership Vouchers use the newer keys, but the old keys are still needed for signing (in the TO0 and TO2 protocols) until all Ownership Vouchers that reference them are processed.","title":"Owner Key Pair Usage"},{"location":"security-best-practices/#runtime-protection-of-owner-signing-keys","text":"The recommendation is to protect owner signing keys using security hardware. However, in large-scale operations with a significant number of accounts, the number of available hardware-protected keys might be limited. In this case, a two-step process should be deployed. The private key corresponding to the public key exposed to the account owner for ownership extension is protected only at rest. The ownership vouchers extended to that public key are then extended to a second public key where the corresponding private key is located in an HSM. The HSM is used to perform the signing operation for the final TO0 process. Since steps 1 and 2 are performed in temporal proximity, it is exactly known how long the private key is needed since Ownership Vouchers are never extended to the associated public key without performing TO0. The two-step process allows simplified key management and rolling the HSM key pair at a regular basis.","title":"Runtime Protection of Owner Signing Keys"},{"location":"security-best-practices/#installer-notes","text":"Secure Device Onboard simplifies the onboarding process by eliminating cumbersome manual provisioning. Such form of automation, however, also creates risks of attacks based on social engineering that should be mitigated by proper installation and verification practices.","title":"Installer Notes"},{"location":"security-best-practices/#verification-of-authenticity-of-devices","text":"Installers shall verify the origin of the devices to be installed. If a device\u2019s origin is not known and the device was exchanged, or tampered with between manufacturing and installation, an adversary can onboard a malicious Secure Device Onboard-enabled device in a target environment without much inside knowledge of the environment. After power-up, the Secure Device Onboard-enabled device would connect to the adversary\u2019s device management service and be under its control.","title":"Verification of Authenticity of Devices"},{"location":"security-best-practices/#installation-complete-test","text":"The danger of introducing a rogue device into the customer\u2019s network is higher when automatic provisioning (including Secure Device Onboard) is used than when each device is manually configured. Under manual configuration, an attacker needs to compromise a device and a person to install it. Under automatic provisioning, the attacker needs only to compromise the device and fool a trusted person to install it. For example, the attacker can switch boxes. After the onboarding process has completed, the installer should verify that the device is under the control of the expected device management service. For example, by evaluating that the device\u2019s serial number shows up in the management console. Keeping a count of systems physically installed and systems newly seen at the management console is also useful. If the device does not report an onboarding error but cannot be verified in the Management service console, the device should not be left connected.","title":"Installation Complete Test"},{"location":"security-best-practices/#network-restrictions-at-installation","text":"The following additional measures are useful to prevent a rogue device from successfully operating in a customer environment, and should be implemented whenever feasible: Network authentication for IoT devices. Secure Device Onboard itself may be used to configure the network authentication into trusted (\u201cnon-rogue\u201d) devices. When all devices must be authenticated to the local network in order to function, a rogue device may be unable to connect to its intended (rogue) manager and thus fail to exfiltrate data. Network security for IoT devices that prevents them from arbitrary connection to the Internet. In many cases, IoT devices need only connect to a few sites on the Internet (for example, for software update, device management, data upload). If network access can be restricted to these sites, a rogue device may be restricted from exfiltrating data. These measures overlap in their effectiveness. In some cases, one may be easier to implement than the other. For security measures, the best policy is to implement both; a belt and suspenders back each other up from embarrassing failures.","title":"Network Restrictions at Installation"},{"location":"security-best-practices/#iot-security-practices-implementation-notes","text":"Secure Device Onboard does not guarantee the security of an IoT device; it just gives a good start. For most of the lifetime of the device, it must secure itself. Indeed, a failure in device security may also allow Secure Device Onboard security to fail. The following best practices are needed to ensure that an IoT device securely implements Secure Device Onboard. In general, these are good security practices that are always recommended. Secure or Verified boot. Ensure that only the desired operating system will load, so expected OS protections are implemented as predicted. Secure the OS and the file system, using one of the many best practices guides available. Secure the Secure Device Onboard programs and data stored on the OS. Deploy the Secure Device Onboard Owner in a protected data-center type environment, where physical and login access is strictly controlled. Protect the keys for the Secure Device Onboard Owner using hardware security (HSM, TPM, and others). Use secure protocols to communicate with IoT devices, and using two-way authentication (from manager to IoT device and IoT device to manager). Use standard protocols (For example, TLS 1.3) and standard implementations, to benefit from the additional security reviews done on them Use the latest versions of these implementations and update them as new ones appear Secure programming practices must be used when implementing Secure Device Onboard components Care must be taken when implementing Secure Device Onboard only to implement the Secure Device Onboard protocols that are needed for this implementation. For example, do not enable the Secure Device Onboard Device protocols for an Secure Device Onboard Owner implementation. Never enable the Secure Device Onboard Device Initialize implementation other than on a Device in manufacturing. EPID revocation information must be updated in a timely manner by Secure Device Onboard Owners. When the Intel\u00ae EPID verification service is used (this is the default), this happens automatically. Secure Device Onboard Devices with a single Trusted Computing Base (no Trusted Execution Environment) must have all the EPID keys in EPID groups only associated with the same product (for example, all keys in EPID groups for a given toaster product, or a given industrial actuator, but no groups with products mixed inside of them). This security practice is useful because Secure Device Onboard EPID authentication is by group membership. If groups contain mixed products, an attacker who penetrates a less valued target (for example, the toaster) may leverage this effort toward a more valued target (for example, a factory with industrial controllers in it). The exception is when Secure Device Onboard is implemented in a trusted execution environment with hardware protection of its own, that is, a separate Trusted Compute Base. In this case, the EPID group may follow the Trusted Compute Base (TCB) for the Secure Device Onboard implementation, and the main execution environment (outside the Trusted Execution Environment) may span many products.","title":"IoT Security Practices, Implementation Notes"},{"location":"client-sdk/client-sdk-api-reference/","text":"FIDO Device Onboard (FDO) Client SDK API Reference \u00b6 This section describes the APIs provided by the FDO Client SDK as well as public data structures required to support them. Data Structures \u00b6 These structures are defined in the FDO Client SDK header file and used by various SDK APIs. Generic API Return Status \u00b6 This type is returned by all APIs and indicates whether the API call succeeded or failed. Syntax typedef enum { FDO_SUCCESS = 0, FDO_INVALID_PATH, FDO_CONFIG_NOT_FOUND, FDO_INVALID_STATE, FDO_RESALE_NOT_SUPPORTED, FDO_RESALE_NOT_READY, FDO_WARNING, FDO_ERROR, FDO_ABORT } fdoSdkStatus; Members FDO_SUCCESS The API call succeeded. FDO_INVALID_PATH A path or address specified was not found or not accessible. FDO_CONFIG_NOT_FOUND An expected configuration file was not found or not accessible. FDO_INVALID_STATE The SDK is in an invalid state to perform the requested operation. FDO_RESALE_NOT_SUPPORTED This configuration of the SDK does not support the Resale Protocol. FDO_RESALE_NOT_READY The SDK is not in a state to execute the Resale Protocol. This error will occur when the Resale API (fdoSdkResale) is called when device ownership transfer has not yet been completed successfully. FDO_WARNING This value is used in the SDK error callback to notify the Application that a transient failure occurred. See Error Handling Callback for details. FDO_ERROR The API call did not succeed. We might extend this later (TBD) to allow returning of specific error types as positive values (for example, memory allocation failure, communications failure, and so on). FDO_ABORT This value is returned by the error callback function to prevent the SDK from continuing the transfer of ownership protocol if an error occurred. Details are provided in Error Handling Callback. FDO Device Status \u00b6 This type indicates the current FDO protocol status of the device. Syntax typedef enum { FDO_STATE_PRE_DI = 2, FDO_STATE_PRE_TO1, FDO_STATE_IDLE, FDO_STATE_RESALE, FDO_STATE_ERROR } fdoSdkDeviceStatus; Members FDO_STATE_PRE_DI The SDK is in the pre-Device Initialization state. It is ready to run the DI protocol which can be initiated by calling the fdoSdkRun() API. FDO_STATE_PRE_TO1 The SDK has completed the DI stage and is ready for Device onboarding. The SDK will run the TO1 protocol if the fdoSdkRun() API is called. FDO_STATE_IDLE The SDK has completed ownership transfer and is in the idle state. Calling fdoSdkRun() will have no effect. The Application may only call the fdoSdkResale() API to initiate the Resale protocol at his point. FDO_STATE_RESALE The SDK has is now ready for resale. Calling fdoSdkRun() will run the TO1 & TO2 protocols, to carryout onboarding to the new (post-resale) device owner. FDO_STATE_ERROR This API failed due to an internal error. FDO SDK Error Values \u00b6 This type is passed from the SDK to the Application when an error occurs and indicates details of the error. It is used by the error callback \u2013 see Error Handling Callback. Syntax typedef enum { FDO_RV_TIMEOUT = 1, FDO_CONN_TIMEOUT, FDO_DI_ERROR, FDO_TO1_ERROR, FDO_TO2_ERROR } fdoSdkError; Members FDO_RV_TIMEOUT A timeout occurred when trying to contact the Rendezvous Server. FDO_CONN_TIMEOUT A connection to either the Rendezvous or Owner Server timed out. FDO_DI_ERROR A generic error occurred during the DI stage. FDO_TO1_ERROR A generic error occurred during the TO1 protocol stage. FDO_TO2_ERROR A generic error occurred during the TO2 protocol stage. FDO Service Callback Type \u00b6 This type value indicates the type of function the module callback must perform. These values are used by the ServiceInfo Module Callback function. Syntax typedef enum { FDO_SI_START, FDO_SI_GET_DSI, FDO_SI_SET_OSI, FDO_SI_END, FDO_SI_FAILURE } fdo_sdk_si_type; Members Below are the parameters of the ServiceInfo Module Callback function described in ServiceInfo Module Callback function. FDO_SI_START This value indicates that the SDK is starting ServiceInfo rounds. The module may perform pre-preparation operations at this time. The count and si parameters will be NULL. FDO_SI_GET_DSI This is a legacy value that shall be removed in a future release. FDO_SI_SET_OSI This value indicates that the SDK is providing a valid Owner ServiceInfo key-value pair to the module and it must process the provide Owner ServiceInfo information. The count parameter is a progressively increasing index value of the provided Owner ServiceInfo. FDO_SI_END This value indicates that the SDK has completed all ServiceInfo rounds and the module can perform cleanup or final operations if required (like saving a file to disk, and so on). FDO_SI_FAILURE This value indicates that an error occurred and the SDK is aborting or abandoning this ServiceInfo round. The module must ignore all the information it has received thus far (if any) and reset to its initial state. Owner ServiceInfo Module Callback \u00b6 This type is a pointer to a callback function that is used to process Owner ServiceInfo messages received from the Owner Server for a specific ServiceInfo module. It takes a pointer to the structure fdor_t whose internal buffer contains the entire message as received in TO2.OwnerServiceInfo (Type 69) with the current position set to the ServiceInfoVal, as well as the ServiceInfoKey (module message). The module must read the ServiceInfoVal from fdor_t , process it as per the ServiceInfoKey, and advance the fdor_t internal buffer to the next valid CBOR entry (currently being done internally in few methods). The module must treat the received fdor_t as a read-only structure, and must never modify it, except advancing to the next CBOR entry. This callback function is invoked in the context of the executing onboarding protocol hence, although there is no fixed timeline, the module must complete execution in the shortest possible time. Syntax typedef int (*fdo_sdk_owner_service_infoCB)( fdo_sdk_si_type type, fdor_t *fdor, char *module_message ); Parameters type This indicates the type of the callback as specified in the FDO Service Callback Type section. fdor A pointer to fdor_t , currently pointing to the ServiceInfoVal to be processed. module_message A pointer to value of ServiceInfoKey representing the module message. Return Value The return value could be one of the following: FDO_SI_CONTENT_ERROR Indicates that the module could not process the ServiceInfo due to invalid content of either the key or value. An error will cause the onboarding protocol to fail and be retried. FDO_SI_INTERNAL_ERROR Indicates that the module could not process the ServiceInfo due to an internal error. An error will cause the onboarding protocol to fail and be retried. FDO_SI_SUCCESS Indicates that the module was able to successfully process the ServiceInfo (or ignored it successfully). ServiceInfo Module Description \u00b6 This structure describes a ServiceInfo module that implements module functionality. Supported modules are known to the Application ahead of time and each module must have one ServiceInfo Module entry, which is passed to the SDK in the fdoSdkInit() API. Syntax typedef struct { bool active; char moduleName[16]; fdo_sdk_owner_service_infoCB serviceInfoCallback; } fdoSdkServiceInfoModule; Members active A bool value denoting whether the ServiceInfo module is currently active(true) or inactive(false). This value is maintained by the SDK and should not be tampered with by the module during ServiceInfo processing. moduleName The symbolic name of the ServiceInfo Module. This should be a NULL terminated string, no larger than 15 characters. serviceInfoCallback This callback function will be invoked by the SDK to pass Owner ServiceInfo to the module. This callback will be executed in the context of the onboarding protocol. See ServiceInfo Module Callback. Error Handling Callback \u00b6 This type is a pointer to a callback function that is used to process errors during protocol execution. The Application can use information provided by this callback to perform application-specific operations. The Application can also control the execution of the protocol state machine by return different values as specified below. Syntax typedef int (*fdoSdkErrorCB)( fdoSdkStatus type, fdoSdkError errorCode ); Parameters type This value specifies the type of error that occurred. It will be one of the following values (other fdoSdkStatus values are not used here): * FDO_ERROR : This indicates an unrecoverable error occurred. The SDK will continue with protocol restart for these types of errors but it is unlikely that the operation will succeed. It is advisable to abort the operation and retry later. * FDO_WARNING : This indicates that a transient error occurred. The SDK will continue with protocol restart, which might fix the problem. It is advisable that the Application allows the restart to take place. errorCode This value indicates details of the error that occurred. See description in FDO SDK Error Values. Return Value The return value could be one of the following constants. NOTE : These values are constants that are defined in the FDO SDK header file. FDO_SUCCESS Indicates that the error was handled and the SDK should continue with its recovery or restart as required. FDO_ABORT This causes the SDK to terminate protocol processing and return to the caller (such as, the fdoSdkRun() API returns). The Application can re-invoke this API later to re-initiate the FDO onboarding process. SDK API Functions \u00b6 The following functions are provided by the SDK and defined in the SDK API header file. Initialize FDO SDK \u00b6 The Application must invoke this API before any other APIs since this API initializes all internal data and state of the SDK. Syntax fdoSdkStatus fdoSdkInit( fdoSdkErrorCB *errorHandlingCallback, uint32_t numModules, fdoSdkModuleInfo *moduleInformation, ); Parameters errorHandlingCallback This is the Application\u2019s error handling function and will be called by the SDK when an error is encountered. This value can be NULL in which case, errors will not be reported to the Application, and the SDK will take the appropriate recovery and/or restart action as required. NOTE : Passing NULL might cause the SDK to remain in an infinite loop until the onboarding process completes successfully. numModules Number of ServiceInfo modules contained in the following moduleInformation list parameter. If no Application-specific modules are available, this value should be zero. moduleInformation Service Module Information description for each available ServiceInfo module as described in ServiceInfo Module Description. If no Application-specific modules are available, this value should be NULL . Return Value This function returns success or an error code as defined in Generic API Return Status. Get Current FDO SDK Status \u00b6 This function returns the current state of the FDO SDK. It may only be called after the SDK has been initialized using the fdoSdkInit() API. Syntax fdoSdkDeviceState fdoSdkGetStatus(void); Return Value This function returns a value of type fdoSdkDeviceStatus as described in FDO Device Status. Execute FDO SDK Onboarding Protocol \u00b6 The Application invokes this API to begin the onboarding process that is, TO1. The onboarding process has completed successfully when this function returns FDO_SUCCESS . If this API returns an error, the Application may retry the onboarding process by calling this API again immediately or after a sleep/reset cycle as determined by the use case. The SDK will invoke the Application error callback if an error occurs in this phase. Additionally, module-specific callbacks will be invoked when ServiceInfo is received from the Owner Server during the TO2 stage. These callbacks are invoked in the context of the callers thread and the callbacks must not call any SDK APIs since the SDK is not yet re-entrant. Syntax fdoSdkStatus fdoSdkRun(void); Return Value This function returns success or an error code as defined in Generic API Return Status. Prepare the FDO SDK for Resale \u00b6 The Application invokes this API to prepare the device for resale. The SDK marks internal state to pre-TO1 and returns. After preparing the SDK for resale, a subsequent call to the fdoSdkRun() API will cause the SDK to perform the TO1 stage again, with new owner credentials that were updated at the end of the previous TO2 protocol stage. Syntax fdoSdkStatus fdoSdkResale(void); Return Value This function returns success or an error code as defined in Generic API Return Status FDO Concise Binary Object Representation (CBOR) encoder/decoder APIs \u00b6 Client SDK uses APIS provided in the header file fdoblockio.h to handle CBOR operations (encode/decode). The API implementations wrap and internally uses the APIs provided by Intel TinyCBOR* library. The structure for writer (encoder) and reader (decoder) are given below: FDO Writer (CBOR Encoder) \u00b6 It is responsible for encoding the buffer inside fdo_block_t into CBOR-encoded stream. Internally, it uses wraps TinyCBOR's CborEncoder into a doubly-linked-list type structure, that is used to manage CBOR container-specific operations (CBOR map/array). The user must perform following operations in sequence to use the FDO Writer struct fdow_t : Allocate memory for fdow_t structure Invoke fdow_init() to fill the allocated memory with 0's Invoke fdo_block_alloc() or fdo_block_alloc_with_size() to allocate memory for fdow_t.b Invoke fdow_encoder_init() to initialize the TinyCBOR's CborEncoder with the previously allocated buffer fdow_t.b . Syntax typedef struct _FDOW_s { fdo_block_t b; int msg_type; fdow_cbor_encoder_t *current; } fdow_t; typedef struct _FDOW_CBOR_ENCODER { CborEncoder cbor_encoder; struct _FDOW_CBOR_ENCODER *next; struct _FDOW_CBOR_ENCODER *previous; } fdow_cbor_encoder_t; Members b The fdo_block_t structure containing the buffer along with its size. The TinyCBOR* library uses this buffer to store the data that has been CBOR-encoded so far. msg_type FDO type (Type 1x/3x/6x/255) current A fdow_cbor_encoder_t structure that resembles a doubly-linked-list, containing TinyCBOR's CborEncoder. FDO Reader (Decoder structure) \u00b6 It is responsible for decoding the CBOR-encoded buffer inside fdo_block_t into binary stream. Internally, it wraps TinyCBOR's CborValue into a doubly-linked-list type structure, that is used to manage CBOR container-specific operations (CBOR map/array). The user must perform following operations in sequence to use the FDO Reader struct fdor_t : Allocate memory for fdor_t structure Invoke fdor_init() to fill the allocated memory with 0's Invoke fdo_block_alloc() or fdo_block_alloc_with_size() to allocate memory for fdor_t.b Copy the CBOR-encoded stream into the previously allocated fdor_t.b Invoke fdor_parser_init() to initialize the TinyCBOR's CBORParser with the previously allocated buffer fdor_t.b . Syntax typedef struct _FDOR_s { fdo_block_t b; int msg_type; bool have_block; CborParser cbor_parser; fdor_cbor_decoder_t *current; } fdor_t; typedef struct _FDOR_CBOR_DECODER { CborValue cbor_value; struct _FDOR_CBOR_DECODER *next; struct _FDOR_CBOR_DECODER *previous; } fdor_cbor_decoder_t; Members b The fdo_block_t structure containing the buffer along with its size. The TinyCBOR* library reads the CBOR-encoded stream from this buffer and decodes them into binary stream. msg_type FDO type (Type 1x/3x/6x/255) have_block A bool value that represents whether the structure contains data to be decoded. Generally, used by the protocol, before decoding is started. cbor_parser CborParser from the TinyCBOR* library. current The fdow_cbor_decoder_t structure that resembles a doubly-linked-list, containing TinyCBOR's CborValue.","title":"Client SDK API Reference"},{"location":"client-sdk/client-sdk-api-reference/#fido-device-onboard-fdo-client-sdk-api-reference","text":"This section describes the APIs provided by the FDO Client SDK as well as public data structures required to support them.","title":"FIDO Device Onboard (FDO) Client SDK API Reference"},{"location":"client-sdk/client-sdk-api-reference/#data-structures","text":"These structures are defined in the FDO Client SDK header file and used by various SDK APIs.","title":"Data Structures"},{"location":"client-sdk/client-sdk-api-reference/#generic-api-return-status","text":"This type is returned by all APIs and indicates whether the API call succeeded or failed. Syntax typedef enum { FDO_SUCCESS = 0, FDO_INVALID_PATH, FDO_CONFIG_NOT_FOUND, FDO_INVALID_STATE, FDO_RESALE_NOT_SUPPORTED, FDO_RESALE_NOT_READY, FDO_WARNING, FDO_ERROR, FDO_ABORT } fdoSdkStatus; Members FDO_SUCCESS The API call succeeded. FDO_INVALID_PATH A path or address specified was not found or not accessible. FDO_CONFIG_NOT_FOUND An expected configuration file was not found or not accessible. FDO_INVALID_STATE The SDK is in an invalid state to perform the requested operation. FDO_RESALE_NOT_SUPPORTED This configuration of the SDK does not support the Resale Protocol. FDO_RESALE_NOT_READY The SDK is not in a state to execute the Resale Protocol. This error will occur when the Resale API (fdoSdkResale) is called when device ownership transfer has not yet been completed successfully. FDO_WARNING This value is used in the SDK error callback to notify the Application that a transient failure occurred. See Error Handling Callback for details. FDO_ERROR The API call did not succeed. We might extend this later (TBD) to allow returning of specific error types as positive values (for example, memory allocation failure, communications failure, and so on). FDO_ABORT This value is returned by the error callback function to prevent the SDK from continuing the transfer of ownership protocol if an error occurred. Details are provided in Error Handling Callback.","title":"Generic API Return Status"},{"location":"client-sdk/client-sdk-api-reference/#fdo-device-status","text":"This type indicates the current FDO protocol status of the device. Syntax typedef enum { FDO_STATE_PRE_DI = 2, FDO_STATE_PRE_TO1, FDO_STATE_IDLE, FDO_STATE_RESALE, FDO_STATE_ERROR } fdoSdkDeviceStatus; Members FDO_STATE_PRE_DI The SDK is in the pre-Device Initialization state. It is ready to run the DI protocol which can be initiated by calling the fdoSdkRun() API. FDO_STATE_PRE_TO1 The SDK has completed the DI stage and is ready for Device onboarding. The SDK will run the TO1 protocol if the fdoSdkRun() API is called. FDO_STATE_IDLE The SDK has completed ownership transfer and is in the idle state. Calling fdoSdkRun() will have no effect. The Application may only call the fdoSdkResale() API to initiate the Resale protocol at his point. FDO_STATE_RESALE The SDK has is now ready for resale. Calling fdoSdkRun() will run the TO1 & TO2 protocols, to carryout onboarding to the new (post-resale) device owner. FDO_STATE_ERROR This API failed due to an internal error.","title":"FDO Device Status"},{"location":"client-sdk/client-sdk-api-reference/#fdo-sdk-error-values","text":"This type is passed from the SDK to the Application when an error occurs and indicates details of the error. It is used by the error callback \u2013 see Error Handling Callback. Syntax typedef enum { FDO_RV_TIMEOUT = 1, FDO_CONN_TIMEOUT, FDO_DI_ERROR, FDO_TO1_ERROR, FDO_TO2_ERROR } fdoSdkError; Members FDO_RV_TIMEOUT A timeout occurred when trying to contact the Rendezvous Server. FDO_CONN_TIMEOUT A connection to either the Rendezvous or Owner Server timed out. FDO_DI_ERROR A generic error occurred during the DI stage. FDO_TO1_ERROR A generic error occurred during the TO1 protocol stage. FDO_TO2_ERROR A generic error occurred during the TO2 protocol stage.","title":"FDO SDK Error Values"},{"location":"client-sdk/client-sdk-api-reference/#fdo-service-callback-type","text":"This type value indicates the type of function the module callback must perform. These values are used by the ServiceInfo Module Callback function. Syntax typedef enum { FDO_SI_START, FDO_SI_GET_DSI, FDO_SI_SET_OSI, FDO_SI_END, FDO_SI_FAILURE } fdo_sdk_si_type; Members Below are the parameters of the ServiceInfo Module Callback function described in ServiceInfo Module Callback function. FDO_SI_START This value indicates that the SDK is starting ServiceInfo rounds. The module may perform pre-preparation operations at this time. The count and si parameters will be NULL. FDO_SI_GET_DSI This is a legacy value that shall be removed in a future release. FDO_SI_SET_OSI This value indicates that the SDK is providing a valid Owner ServiceInfo key-value pair to the module and it must process the provide Owner ServiceInfo information. The count parameter is a progressively increasing index value of the provided Owner ServiceInfo. FDO_SI_END This value indicates that the SDK has completed all ServiceInfo rounds and the module can perform cleanup or final operations if required (like saving a file to disk, and so on). FDO_SI_FAILURE This value indicates that an error occurred and the SDK is aborting or abandoning this ServiceInfo round. The module must ignore all the information it has received thus far (if any) and reset to its initial state.","title":"FDO Service Callback Type"},{"location":"client-sdk/client-sdk-api-reference/#owner-serviceinfo-module-callback","text":"This type is a pointer to a callback function that is used to process Owner ServiceInfo messages received from the Owner Server for a specific ServiceInfo module. It takes a pointer to the structure fdor_t whose internal buffer contains the entire message as received in TO2.OwnerServiceInfo (Type 69) with the current position set to the ServiceInfoVal, as well as the ServiceInfoKey (module message). The module must read the ServiceInfoVal from fdor_t , process it as per the ServiceInfoKey, and advance the fdor_t internal buffer to the next valid CBOR entry (currently being done internally in few methods). The module must treat the received fdor_t as a read-only structure, and must never modify it, except advancing to the next CBOR entry. This callback function is invoked in the context of the executing onboarding protocol hence, although there is no fixed timeline, the module must complete execution in the shortest possible time. Syntax typedef int (*fdo_sdk_owner_service_infoCB)( fdo_sdk_si_type type, fdor_t *fdor, char *module_message ); Parameters type This indicates the type of the callback as specified in the FDO Service Callback Type section. fdor A pointer to fdor_t , currently pointing to the ServiceInfoVal to be processed. module_message A pointer to value of ServiceInfoKey representing the module message. Return Value The return value could be one of the following: FDO_SI_CONTENT_ERROR Indicates that the module could not process the ServiceInfo due to invalid content of either the key or value. An error will cause the onboarding protocol to fail and be retried. FDO_SI_INTERNAL_ERROR Indicates that the module could not process the ServiceInfo due to an internal error. An error will cause the onboarding protocol to fail and be retried. FDO_SI_SUCCESS Indicates that the module was able to successfully process the ServiceInfo (or ignored it successfully).","title":"Owner ServiceInfo Module Callback"},{"location":"client-sdk/client-sdk-api-reference/#serviceinfo-module-description","text":"This structure describes a ServiceInfo module that implements module functionality. Supported modules are known to the Application ahead of time and each module must have one ServiceInfo Module entry, which is passed to the SDK in the fdoSdkInit() API. Syntax typedef struct { bool active; char moduleName[16]; fdo_sdk_owner_service_infoCB serviceInfoCallback; } fdoSdkServiceInfoModule; Members active A bool value denoting whether the ServiceInfo module is currently active(true) or inactive(false). This value is maintained by the SDK and should not be tampered with by the module during ServiceInfo processing. moduleName The symbolic name of the ServiceInfo Module. This should be a NULL terminated string, no larger than 15 characters. serviceInfoCallback This callback function will be invoked by the SDK to pass Owner ServiceInfo to the module. This callback will be executed in the context of the onboarding protocol. See ServiceInfo Module Callback.","title":"ServiceInfo Module Description"},{"location":"client-sdk/client-sdk-api-reference/#error-handling-callback","text":"This type is a pointer to a callback function that is used to process errors during protocol execution. The Application can use information provided by this callback to perform application-specific operations. The Application can also control the execution of the protocol state machine by return different values as specified below. Syntax typedef int (*fdoSdkErrorCB)( fdoSdkStatus type, fdoSdkError errorCode ); Parameters type This value specifies the type of error that occurred. It will be one of the following values (other fdoSdkStatus values are not used here): * FDO_ERROR : This indicates an unrecoverable error occurred. The SDK will continue with protocol restart for these types of errors but it is unlikely that the operation will succeed. It is advisable to abort the operation and retry later. * FDO_WARNING : This indicates that a transient error occurred. The SDK will continue with protocol restart, which might fix the problem. It is advisable that the Application allows the restart to take place. errorCode This value indicates details of the error that occurred. See description in FDO SDK Error Values. Return Value The return value could be one of the following constants. NOTE : These values are constants that are defined in the FDO SDK header file. FDO_SUCCESS Indicates that the error was handled and the SDK should continue with its recovery or restart as required. FDO_ABORT This causes the SDK to terminate protocol processing and return to the caller (such as, the fdoSdkRun() API returns). The Application can re-invoke this API later to re-initiate the FDO onboarding process.","title":"Error Handling Callback"},{"location":"client-sdk/client-sdk-api-reference/#sdk-api-functions","text":"The following functions are provided by the SDK and defined in the SDK API header file.","title":"SDK API Functions"},{"location":"client-sdk/client-sdk-api-reference/#initialize-fdo-sdk","text":"The Application must invoke this API before any other APIs since this API initializes all internal data and state of the SDK. Syntax fdoSdkStatus fdoSdkInit( fdoSdkErrorCB *errorHandlingCallback, uint32_t numModules, fdoSdkModuleInfo *moduleInformation, ); Parameters errorHandlingCallback This is the Application\u2019s error handling function and will be called by the SDK when an error is encountered. This value can be NULL in which case, errors will not be reported to the Application, and the SDK will take the appropriate recovery and/or restart action as required. NOTE : Passing NULL might cause the SDK to remain in an infinite loop until the onboarding process completes successfully. numModules Number of ServiceInfo modules contained in the following moduleInformation list parameter. If no Application-specific modules are available, this value should be zero. moduleInformation Service Module Information description for each available ServiceInfo module as described in ServiceInfo Module Description. If no Application-specific modules are available, this value should be NULL . Return Value This function returns success or an error code as defined in Generic API Return Status.","title":"Initialize FDO SDK"},{"location":"client-sdk/client-sdk-api-reference/#get-current-fdo-sdk-status","text":"This function returns the current state of the FDO SDK. It may only be called after the SDK has been initialized using the fdoSdkInit() API. Syntax fdoSdkDeviceState fdoSdkGetStatus(void); Return Value This function returns a value of type fdoSdkDeviceStatus as described in FDO Device Status.","title":"Get Current FDO SDK Status"},{"location":"client-sdk/client-sdk-api-reference/#execute-fdo-sdk-onboarding-protocol","text":"The Application invokes this API to begin the onboarding process that is, TO1. The onboarding process has completed successfully when this function returns FDO_SUCCESS . If this API returns an error, the Application may retry the onboarding process by calling this API again immediately or after a sleep/reset cycle as determined by the use case. The SDK will invoke the Application error callback if an error occurs in this phase. Additionally, module-specific callbacks will be invoked when ServiceInfo is received from the Owner Server during the TO2 stage. These callbacks are invoked in the context of the callers thread and the callbacks must not call any SDK APIs since the SDK is not yet re-entrant. Syntax fdoSdkStatus fdoSdkRun(void); Return Value This function returns success or an error code as defined in Generic API Return Status.","title":"Execute FDO SDK Onboarding Protocol"},{"location":"client-sdk/client-sdk-api-reference/#prepare-the-fdo-sdk-for-resale","text":"The Application invokes this API to prepare the device for resale. The SDK marks internal state to pre-TO1 and returns. After preparing the SDK for resale, a subsequent call to the fdoSdkRun() API will cause the SDK to perform the TO1 stage again, with new owner credentials that were updated at the end of the previous TO2 protocol stage. Syntax fdoSdkStatus fdoSdkResale(void); Return Value This function returns success or an error code as defined in Generic API Return Status","title":"Prepare the FDO SDK for Resale"},{"location":"client-sdk/client-sdk-api-reference/#fdo-concise-binary-object-representation-cbor-encoderdecoder-apis","text":"Client SDK uses APIS provided in the header file fdoblockio.h to handle CBOR operations (encode/decode). The API implementations wrap and internally uses the APIs provided by Intel TinyCBOR* library. The structure for writer (encoder) and reader (decoder) are given below:","title":"FDO Concise Binary Object Representation (CBOR) encoder/decoder APIs"},{"location":"client-sdk/client-sdk-api-reference/#fdo-writer-cbor-encoder","text":"It is responsible for encoding the buffer inside fdo_block_t into CBOR-encoded stream. Internally, it uses wraps TinyCBOR's CborEncoder into a doubly-linked-list type structure, that is used to manage CBOR container-specific operations (CBOR map/array). The user must perform following operations in sequence to use the FDO Writer struct fdow_t : Allocate memory for fdow_t structure Invoke fdow_init() to fill the allocated memory with 0's Invoke fdo_block_alloc() or fdo_block_alloc_with_size() to allocate memory for fdow_t.b Invoke fdow_encoder_init() to initialize the TinyCBOR's CborEncoder with the previously allocated buffer fdow_t.b . Syntax typedef struct _FDOW_s { fdo_block_t b; int msg_type; fdow_cbor_encoder_t *current; } fdow_t; typedef struct _FDOW_CBOR_ENCODER { CborEncoder cbor_encoder; struct _FDOW_CBOR_ENCODER *next; struct _FDOW_CBOR_ENCODER *previous; } fdow_cbor_encoder_t; Members b The fdo_block_t structure containing the buffer along with its size. The TinyCBOR* library uses this buffer to store the data that has been CBOR-encoded so far. msg_type FDO type (Type 1x/3x/6x/255) current A fdow_cbor_encoder_t structure that resembles a doubly-linked-list, containing TinyCBOR's CborEncoder.","title":"FDO Writer (CBOR Encoder)"},{"location":"client-sdk/client-sdk-api-reference/#fdo-reader-decoder-structure","text":"It is responsible for decoding the CBOR-encoded buffer inside fdo_block_t into binary stream. Internally, it wraps TinyCBOR's CborValue into a doubly-linked-list type structure, that is used to manage CBOR container-specific operations (CBOR map/array). The user must perform following operations in sequence to use the FDO Reader struct fdor_t : Allocate memory for fdor_t structure Invoke fdor_init() to fill the allocated memory with 0's Invoke fdo_block_alloc() or fdo_block_alloc_with_size() to allocate memory for fdor_t.b Copy the CBOR-encoded stream into the previously allocated fdor_t.b Invoke fdor_parser_init() to initialize the TinyCBOR's CBORParser with the previously allocated buffer fdor_t.b . Syntax typedef struct _FDOR_s { fdo_block_t b; int msg_type; bool have_block; CborParser cbor_parser; fdor_cbor_decoder_t *current; } fdor_t; typedef struct _FDOR_CBOR_DECODER { CborValue cbor_value; struct _FDOR_CBOR_DECODER *next; struct _FDOR_CBOR_DECODER *previous; } fdor_cbor_decoder_t; Members b The fdo_block_t structure containing the buffer along with its size. The TinyCBOR* library reads the CBOR-encoded stream from this buffer and decodes them into binary stream. msg_type FDO type (Type 1x/3x/6x/255) have_block A bool value that represents whether the structure contains data to be decoded. Generally, used by the protocol, before decoding is started. cbor_parser CborParser from the TinyCBOR* library. current The fdow_cbor_decoder_t structure that resembles a doubly-linked-list, containing TinyCBOR's CborValue.","title":"FDO Reader (Decoder structure)"},{"location":"client-sdk/client-sdk-design/","text":"Introduction \u00b6 This document describes the changes required in the FIDO Device Onboard (FDO) Client Software Development Kit (SDK) to support the new FIDO Device Onboard specification . The FDO Client SDK is a portable C Code implementation of the FDO Device Onboarding (FDO) protocols, cryptographic operations, and associated functions required to support microcontroller (MCU) devices. The SDK is written in C since it is the language of choice for programming MCU devices. While the SDK is developed and tested on Linux, the core components of the SDK are isolated from Linux specifics via an abstraction layer. Well-known open source implementations of cryptographic libraries are used for crypto operations. The reader is expected to be familiar with MCUs in general \u2013 their SW & HW characteristics, how they are used, typical applications, their lifecycle, etc. FDO Client SDK Design \u00b6 The design is divided into different blocks of FDO specific implementation. This document does not specify API-level design, but rather specifies the block-level and call-level design of the FDO design. The existing REST/JSON based protocols currently implemented in the Client SDK are replaced by the CBOR-based protocols described in the FIDO Device Onboard Proposed Standard. Please refer to the FDO specification for complete details of the new draft protocols. Figure 1. Basic Block Diagram Changes to be Made in Client SDK \u00b6 There are a few blocks and implementations to be either fully rewritten or modified to make the Client SDK compatible with the FDO specification. Those changes are described in the following sections: CBOR \u2013 COSE HAL Library (A1) \u00b6 This block implements the following functionality: CBOR Encode API \u2013 Uses the TinyCBOR library calls directly to encode data provided from upper layer to create CBOR data stream. Data is provided back to FDO library to be sent using the network layer. CBOR Decode API \u2013 Uses TinyCBOR library calls directly to decode received CBOR encoded data from servers. Library calls may be used recursively. CBOR COSE APIs \u2013 Implements the COSE API requirement using the Crypto HAL API calls as well as using TinyCBOR APIs calls. Refer to the FDO specification for further details on API requirements. Documentation for the TinyCBOR library can be found here . Source code for the TinyCBOR library can be found here . Protocol Message Layer (A2) \u00b6 This layer must be adapted to the new FDO implementation. Each message API must be revisited and re-implemented as required to comply with the FDO message structure. This layer will extensively use CBOR-COSE HAL layer. ServiceInfo Message Handling (A3) \u00b6 The FDO specification requires changes to the handling of ServiceInfo messages. Handling of ServiceInfo is done almost similar to the previous specification; however, the repeat transmit, acknowledgement, and DSI messages require full implementation in the FDO library. Unlike the current implementation, service message must be part of the FDO library rather than a separate module. Storage Implementation - CBOR Format (A4) \u00b6 Currently, all manufacturer information and device secrets are stored in persistent storage in JSON format. The new FDO specification uses CBOR as the data encoding format, and so all data stored in persistent storage must be done using CBOR encoding. This will reduce confusion and discourage the user from using multiple data storage formats. All file save and load APIs must be rewritten using CBOR-COSE APIs to replace JSON encoding and decoding. Fido Message Handling \u00b6 The following is the detailed design for handling FDO CBOR messages in the Client SDK implementation. Figure 2. FDO Message Handling CBOR\u2013COSE HAL API Library will be used to decode and encode messages. Crypto HAL calls will be reutilized. If additional Crypto HAL APIs are required by CDDL they can be added as part of Crypto HAL layers. Figure 3. FDO Transmit Message Flowchart Figure 4. FDO Receive Message Flowchart Further Client SDK porting details can be found here .","title":"Client SDK Design"},{"location":"client-sdk/client-sdk-design/#introduction","text":"This document describes the changes required in the FIDO Device Onboard (FDO) Client Software Development Kit (SDK) to support the new FIDO Device Onboard specification . The FDO Client SDK is a portable C Code implementation of the FDO Device Onboarding (FDO) protocols, cryptographic operations, and associated functions required to support microcontroller (MCU) devices. The SDK is written in C since it is the language of choice for programming MCU devices. While the SDK is developed and tested on Linux, the core components of the SDK are isolated from Linux specifics via an abstraction layer. Well-known open source implementations of cryptographic libraries are used for crypto operations. The reader is expected to be familiar with MCUs in general \u2013 their SW & HW characteristics, how they are used, typical applications, their lifecycle, etc.","title":"Introduction"},{"location":"client-sdk/client-sdk-design/#fdo-client-sdk-design","text":"The design is divided into different blocks of FDO specific implementation. This document does not specify API-level design, but rather specifies the block-level and call-level design of the FDO design. The existing REST/JSON based protocols currently implemented in the Client SDK are replaced by the CBOR-based protocols described in the FIDO Device Onboard Proposed Standard. Please refer to the FDO specification for complete details of the new draft protocols. Figure 1. Basic Block Diagram","title":"FDO Client SDK Design"},{"location":"client-sdk/client-sdk-design/#changes-to-be-made-in-client-sdk","text":"There are a few blocks and implementations to be either fully rewritten or modified to make the Client SDK compatible with the FDO specification. Those changes are described in the following sections:","title":"Changes to be Made in Client SDK"},{"location":"client-sdk/client-sdk-design/#cbor-cose-hal-library-a1","text":"This block implements the following functionality: CBOR Encode API \u2013 Uses the TinyCBOR library calls directly to encode data provided from upper layer to create CBOR data stream. Data is provided back to FDO library to be sent using the network layer. CBOR Decode API \u2013 Uses TinyCBOR library calls directly to decode received CBOR encoded data from servers. Library calls may be used recursively. CBOR COSE APIs \u2013 Implements the COSE API requirement using the Crypto HAL API calls as well as using TinyCBOR APIs calls. Refer to the FDO specification for further details on API requirements. Documentation for the TinyCBOR library can be found here . Source code for the TinyCBOR library can be found here .","title":"CBOR \u2013 COSE HAL Library (A1)"},{"location":"client-sdk/client-sdk-design/#protocol-message-layer-a2","text":"This layer must be adapted to the new FDO implementation. Each message API must be revisited and re-implemented as required to comply with the FDO message structure. This layer will extensively use CBOR-COSE HAL layer.","title":"Protocol Message Layer (A2)"},{"location":"client-sdk/client-sdk-design/#serviceinfo-message-handling-a3","text":"The FDO specification requires changes to the handling of ServiceInfo messages. Handling of ServiceInfo is done almost similar to the previous specification; however, the repeat transmit, acknowledgement, and DSI messages require full implementation in the FDO library. Unlike the current implementation, service message must be part of the FDO library rather than a separate module.","title":"ServiceInfo Message Handling (A3)"},{"location":"client-sdk/client-sdk-design/#storage-implementation-cbor-format-a4","text":"Currently, all manufacturer information and device secrets are stored in persistent storage in JSON format. The new FDO specification uses CBOR as the data encoding format, and so all data stored in persistent storage must be done using CBOR encoding. This will reduce confusion and discourage the user from using multiple data storage formats. All file save and load APIs must be rewritten using CBOR-COSE APIs to replace JSON encoding and decoding.","title":"Storage Implementation - CBOR Format (A4)"},{"location":"client-sdk/client-sdk-design/#fido-message-handling","text":"The following is the detailed design for handling FDO CBOR messages in the Client SDK implementation. Figure 2. FDO Message Handling CBOR\u2013COSE HAL API Library will be used to decode and encode messages. Crypto HAL calls will be reutilized. If additional Crypto HAL APIs are required by CDDL they can be added as part of Crypto HAL layers. Figure 3. FDO Transmit Message Flowchart Figure 4. FDO Receive Message Flowchart Further Client SDK porting details can be found here .","title":"Fido Message Handling"},{"location":"client-sdk/client-sdk-porting-guide/","text":"Porting Guide \u00b6 This document provides a guide to porting the Client SDK to new platforms. Solution Architecture \u00b6 The Client SDK reference solution is comprised of 3 layers: Application : The reference application which triggers the Device Initialization and Ownership Transfer State Machine. Library : The Device Initialization and Ownership Transfer Protocol implementation for FIDO Device Onboard Proposed Standard. Platform : Platform-specific implementation. The Platform layer is itself comprised of three modules: Crypto, Network, and Storage: Crypto : Implementation of Cryptographic requirements of Ownership Transfer Protocol. This also abstracts the \u201cPlatform\u201d specific crypto methods from the \u201cLibrary\u201d. So, the crypto implementation is divided into: Library specific implementation: There is no impact of adding new platform Platform specific implementation: The impact of adding new platform is detailed in Crypto Subsystem API section below. Network : Implementation of Networking. This abstracts the \u201cPlatform\u201d specific networking functionality from \u201cLibrary\u201d. The impact of adding new platform is detailed in the Network Subsystem API section below. Storage : Implementation of Secure Storage. This abstracts the \u201cPlatform\u201d specific storage methods from \u201cLibrary\u201d. The impact of adding new platform is detailed in the Storage Subsystem API section below. \u2003 Code Structure \u00b6 The Client SDK reference implementation source code is organized as follows (folders that are discussed in this porting guide are indicated with \"*\"): \u251c\u2500\u2500 app - - - - - - Reference Application \u251c\u2500\u2500 crypto* - - - - Crypto Subsystem \u251c\u2500\u2500 cmake* - - - - - cmake sub files \u251c\u2500\u2500 data - - - - - - Filesystem place to store blob like keys, network info. \u251c\u2500\u2500 device_modules - ServiceInfo Modules \u251c\u2500\u2500 docs - - - - - - Documents \u251c\u2500\u2500 include - - - - Client SDK APIs \u251c\u2500\u2500 lib - - - - - - The core protocol implementation \u251c\u2500\u2500 mbedos - - - - - mbedos based Client SDK implementation \u251c\u2500\u2500 network* - - - - Network subsystem \u251c\u2500\u2500 NOTICES - - - - License specific information \u251c\u2500\u2500 storage* - - - - Storage Subsystem \u2514\u2500\u2500 utils - - - - - Reference files for setting up TPM, flashing etc. Build System \u00b6 Starting with release v1.9.0 of the Client SDK, the build system uses cmake. This section explains the most prominent configurations in build system. The reference application is tightly coupled with the build system, storage and crypto APIs. The intent of this section is to cover those specific bindings to make the solution easy to traverse. \u251c\u2500\u2500 app \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 cmake \u2502 \u251c\u2500\u2500 blob_path.cmake \u2502 \u251c\u2500\u2500 cli_input.cmake \u2502 \u251c\u2500\u2500 extension.cmake \u2502 \u2514\u2500\u2500 pristine.cmake \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 crypto \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 device_modules \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 mbedos \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 network \u2502 \u2514\u2500\u2500 CMakeLists.txt \u2514\u2500\u2500 storage \u2514\u2500\u2500 CMakeLists.txt cli_input.cmake (erstwhile base.mk) \u00b6 The base.mk was used to define the build flags as a top-level configuration Makefile. The cli_input.cmake still retains that property, however, the blob specific configuration is moved to blob_path.cmake. The following specifies the default build configuration which can be overridden in invocation of cmake. set (TARGET_OS linux) set (CSTD c99) set (TLS openssl) set (DA ecdsa384) set (AES_MODE gcm) set (BUILD debug) set (TARGET_OS linux) set (HTTPPROXY true) set (PROXY_DISCOVERY false) set (OPTIMIZE 1) set (DA_FILE der) set (CRYPTO_HW false) set (ARCH x86) set (RETRY true) set (unit-test false) set (STORAGE true) set (BOARD NUCLEO_F767ZI) set (BLOB_PATH .) set (TPM2_TCTI_TYPE tabrmd) set (RESALE true) set (REUSE true) blob_path.cmake \u00b6 The blob specific paths are set with this cmake file. A new variable BLOB_PATH is introduced to customize the placement of blobs in the filesystem. client_sdk_compile_definitions( -DSERIAL_FILE=\\\"${BLOB_PATH}/data/manufacturer_sn.bin\\\" -DMODEL_FILE=\\\"${BLOB_PATH}/data/manufacturer_mod.bin\\\" -DPLATFORM_IV=\\\"${BLOB_PATH}/data/platform_iv.bin\\\" -DPLATFORM_HMAC_KEY=\\\"${BLOB_PATH}/data/platform_hmac_key.bin\\\" -DPLATFORM_AES_KEY=\\\"${BLOB_PATH}/data/platform_aes_key.bin\\\" -DEPID_PRIVKEY=\\\"${BLOB_PATH}/data/epidprivkey.dat\\\" -DFDO_CRED=\\\"${BLOB_PATH}/data/PMDeviceCredentials.bin\\\" -DMANUFACTURER_ADDR=\\\"${BLOB_PATH}/data/manufacturer_addr.bin\\\" -DMAX_SERVICEINFO_SZ_FILE=\\\"${BLOB_PATH}/data/max_serviceinfo_sz.bin\\\" ) client_sdk_compile_definitions( -DFDO_CACERT=\\\"${BLOB_PATH}/data/cacert.bin\\\" -DFDO_PUBKEY=\\\"${BLOB_PATH}/data/pubkey.dat\\\" -DFDO_SIGRL=\\\"${BLOB_PATH}/data/sigrl.dat\\\" -DFDO_CRED_SECURE=\\\"${BLOB_PATH}/data/Secure.blob\\\" -DFDO_CRED_MFG=\\\"${BLOB_PATH}/data/Mfg.blob\\\" -DFDO_CRED_NORMAL=\\\"${BLOB_PATH}/data/Normal.blob\\\" ) FDO_CRED_NORMAL - Normal.blob \u00b6 The Client SDK or Device lifecycle is maintained in this blob. This data is stored as Authenticated Data meaning that HMAC256 is calculated over this data and stored back. Note This is part of custom storage implementation in reference solution. Please refer Storage Subsystem API for details required for implementation on custom platform. The Application may use APIs listed in Storage Subsystem API, to manipulate blobs, so, the blobs remain consistent as expected by Client SDK. However, the APIs mentioned in the above said section are internal APIs and it is up to the application developer to reuse them. The application, before starting the state machine by calling fdo_sdk_init() generates the HMAC over this data and stores it back along with the data. This is initialized to the following value to indicate that the device is in manufactured state. It also allows the reference application to perform multiple cycles of FIDO Device Onboard operation. blob_path.cmake: file(WRITE ${BLOB_PATH}/data/Normal.blob \"{\\\"ST\\\":1}\") PLATFORM_(IV/HMAC_KEY/AES_KEY) \u00b6 The purpose of these defines is to specify the location where the reference solution stores the following information: PLATFORM_IV: Initialization Vector used in Authenticated Encryption of Secure Blobs. The Secure Blobs are internal to Client SDK and are not controlled by the application. PLATFORM_HMAC_KEY: HMAC key to authenticate Normal.blob or any other internal blob which only needs Authenticated read. PLATFORM_AES_KEY: AES key to Authenticate Encrypt the Secure Blobs. The Secure Blobs are internal to Client SDK and are not controlled by the application. Note These flags are not necessary for the platforms which have their own Secure Storage mechanisms. The platform may be able to store all blobs using Authenticated Encryption including Normal.blob. Client SDK always uses fdo_blob_read() to read the data, so, the underlying detail is already abstracted. In the reference solution, it is expected that these files exist physically although without any content. The content gets generated on an as-needed basis. MANUFACTURER_ADDR \u00b6 Client SDK uses the location defined in the specified file to connect to Manufacturer Server to perform Device Initialization. The format for the Manufacturer Address is of the form: {http,https}://{DNS,IP}:port . The following rules apply while setting the value and all of these are mandatory: The transport protocol value must be either http or https (case-sensitive). Any other value will result in an error. Either one of DNS or IP Address can be provided. The maximum value of DNS is 100 characters and must only contain alphanumeric characters (0-9A-za-z), hyphens (-) and dot (.). The port should be an integer between (1-65535). The URL separators :// and : should be present at appropriate indices as per the indices of the above values. MAX_SERVICEINFO_SZ_FILE \u00b6 Client SDK uses the value contained in the file path as defined by this flag, to decide the maximum ServiceInfo size the Device can process. The value must lie between 256 and 8192 (both inclusive). If the set value is less than 256, the value would default to 256. Similarly, if the value is greater than 8192, the value would default to 8192. ECDSA_PRIVKEY \u00b6 This specifies the ECDSA private key to be used as a device identity. Two options are possible: The key could be pre-created like the reference application. If the device supports secure storage, then the key can be generated within the device and stored using secure storage APIs Note This section is not a recommendation, but specifies some of the possibilities that exist. FDO_CRED_(SECURE/MFG) \u00b6 These defines are used internally by Client SDK: FDO_CRED_SECURE: This define specifies the location of the device secret. This blob is Authenticated Encrypted in the reference solution. FDO_CRED_MFG: This define specifies the location of Manufacturer data. This blob is stored with Authenticated information. extension.cmake (erstwhile crypto.conf) \u00b6 This cmake file consists mostly of build configuration from crypto.conf but is not limited to it. Supported Configurations \u00b6 The following content is retained from crypto.conf for readability. ### Device Attestation validation SUPPORTED_DA = ecdsa256 ecdsa384 tpm20_ecdsa256 ### AES mode for secure channel SUPPORTED_AES_MODE = gcm ccm SUPPORTED_DA: This specifies the supported Device Attestation algorithms which device uses to prove its identity to Rendezvous Server and Owner. This automatically configures the Key Exchange algorithm (ECDH256/ECDH384) that is used to generate the shared secret and the AES Mode, to use higher crypto in the source. Note tpm20_ecdsa256 isn\u2019t a separate algorithm, it uses ecdsa256 as Device Attestation, but uses TPM2.0 to generate keys and store data Note The Public Key Encoding supported in COSEX509. SUPPORTED_AES_MODE: This specifies the AES mode of encryption supported by device. The device supports GCM and CCM. The following configurations are supported as per the Device Attestation algorithm: A128GCM, A256GCM, AES-CCM-64-128-128 and AES-CCM-64-128-256. Client SDK Constants \u00b6 fdo_sdk_error \u00b6 typedef enum { FDO_RV_TIMEOUT = 1, FDO_CONN_TIMEOUT, FDO_DI_ERROR, FDO_TO1_ERROR, FDO_TO2_ERROR } fdo_sdk_error; The usage of this enum is detailed in fdo_sdk_init() fdo_sdk_status \u00b6 typedef enum { FDO_SUCCESS, FDO_INVALID_PATH, FDO_CONFIG_NOT_FOUND, FDO_INVALID_STATE, FDO_RESALE_NOT_SUPPORTED, FDO_RESALE_NOT_READY, FDO_WARNING, FDO_ERROR, FDO_ABORT } fdo_sdk_status; The usage of this enum is detailed in fdo_sdk_init() fdo_sdk_device_state \u00b6 typedef enum { FDO_STATE_PRE_DI = 2, FDO_STATE_PRE_TO1, FDO_STATE_IDLE, FDO_STATE_RESALE, FDO_STATE_ERROR } fdo_sdk_device_state; The usage of this enum is detailed in fdo_sdk_get_status() Client SDK Functions \u00b6 The application resides in the app directory of the reference solution. The application uses the APIs specified in include/fdo.h to trigger the Ownership transfer state machine. The following lists the APIs which the application uses to perform Device Initialization or start Ownership Transfer Protocol. fdo_sdk_init() \u00b6 fdo_sdk_status fdo_sdk_init(fdo_sdk_errorCB error_handling_callback, uint32_t num_modules, fdo_sdk_service_info_module *module_information); typedef int (*fdo_sdk_errorCB)(fdo_sdk_status type, fdo_sdk_error error_code); Description This function initializes the Client SDK data structures. It allows the application to control the error handling of the Client SDK state machine by setting error_handling_callback. Client SDK calls error_handling_callback to propagate the error_code(fdo_sdk_error) back to the application with Client SDK internal status fdo_sdk_status(fdo_sdk_status). The application may handle the error and return the appropriate action to be taken by Client SDK further. Note The reference application allows the Client SDK to retry 5 times before calling abort The Client SDK allows the owner to download the required Device Management System agents via ServiceInfo mechanism; the num_modules and module_information registers the ServiceInfo modules with the Client SDK. Parameters error_handling_callback: It is of type fdo_sdk_errorCB num_modules: number of ServiceInfo modules to register. module_information: Array of ServiceInfo modules registration information Return Value FDO_SUCCESS for success. Greater than FDO_SUCCESS for failure (refer fdo_sdk_status) fdo_sdk_run() \u00b6 fdo_sdk_status fdo_sdk_run(void); Description This function triggers either the Device Initialize state machine or Ownership Transfer Protocol state machine depending on the device status stored in Normal.blob. Note The reference application's first successful execution performs Device Initialization. The second execution begins to perform Ownership Transfer Protocol. Parameters None Return Value FDO_SUCCESS for success. Greater than FDO_SUCCESS for failure (refer fdo_sdk_status) fdo_sdk_resale() \u00b6 fdo_sdk_status fdo_sdk_resale(void); Description This function triggers the device resale. Parameters None Return Value FDO_SUCCESS for success. Greater than FDO_SUCCESS for failure (refer fdo_sdk_status) fdo_sdk_get_status() \u00b6 fdo_sdk_device_state fdo_sdk_get_status(void); Description This function returns the current state of the device. Parameters None Return Value Please refer fdo_sdk_status: FDO_STATE_PRE_DI: Device is ready for DI FDO_STATE_PRE_TO1: Device is ready for Ownership transfer FDO_STATE_IDLE: Device's ownership transfer done FDO_STATE_RESALE: Device is ready for ownership transfer FDO_STATE_ERROR: Error in getting device status Crypto Subsystem API \u00b6 Cryptography support is a platform offering which enables Client SDK to generate random number, perform encryption, signing, sign verification and so on. The required functionality by the Client SDK is abstracted via a set of APIs declared in file \"crypto/include/fdoCryptoHal.h\" and \"crypto/include/base64.h\" Note This section of the document specifies the internal APIs to abstract Crypto implementation from Client SDK and are subject to change. Constants \u00b6 FDO_CRYPTO_HASH_TYPE \u00b6 #define FDO_CRYPTO_HASH_TYPE_SHA_256 -16 #define FDO_CRYPTO_HASH_TYPE_SHA_384 -43 The usage of this define is detailed in crypto_hal_hash() . FDO_CRYPTO_HMAC_TYPE \u00b6 #define FDO_CRYPTO_HMAC_TYPE_SHA_256 5 #define FDO_CRYPTO_HMAC_TYPE_SHA_384 6 The usage of this define is detailed in crypto_hal_hmac() . FDO_CRYPTO_PUB_KEY_ENCODING \u00b6 #define FDO_CRYPTO_PUB_KEY_ENCODING_COSEX509 2 The usage of this define is detailed in crypto_hal_sig_verify() . FDO_CRYPTO_PUB_KEY_ALGO \u00b6 #define FDO_CRYPTO_PUB_KEY_ALGO_ECDSAp256 -7 #define FDO_CRYPTO_PUB_KEY_ALGO_ECDSAp384 -35 The usage of this define is detailed in crypto_hal_sig_verify() . Structures \u00b6 fdo_byte_array_t \u00b6 typedef struct { size_t byte_sz; uint8_t * bytes; } fdo_bits_t; typedef fdo_bits_t fdo_byte_array_t; The usage is detailed in crypto_hal_get_device_csr() . Initialization and Exit Functions \u00b6 crypto_init() \u00b6 int32_t crypto_init(void) Description This function initializes and enables the crypto services to be used by Client SDK. Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure random number generation requirements for your device, refer to the Client SDK Security Implications document. Parameters None Return Value 0 for success -1 for failure crypto_close() \u00b6 int32_t crypto_close(void) Description This function tears down any initialization done to enable crypto services to Client SDK. Note This function may require a change in implementation for porting to custom platform, as it tears down the initialization done in crypto_init() . Also, the crypto tear down could be different for custom platforms. Parameters None Return Value 0 for success -1 for failure Random Number Functions \u00b6 random_init() \u00b6 int random_init(void) Description This function initializes the random number generator functionality. Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure random number generation requirements for your device, refer to the Client SDK Security Implications document. Parameters None Return Value 0 for success -1 for failure random_close() \u00b6 int random_close(void) Description This function releases the random number context. After this call, the random number cannot be retrieved from a call to crypto_hal_random_bytes() Note This function may require a change in implementation for porting to custom platform, as it tears down the initialization done to setup random number generator which may be different in custom platform Parameters None Return Value 0 for success -1 for failure crypto_hal_random_bytes() \u00b6 int32_t crypto_hal_random_bytes(uint8_t *random_buffer, size_t num_bytes) Description This function fills the random_buffer with the random number of size num_bytes. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters random_buffer: pointer to memory to receive random number num_bytes: size of memory pointed by random_buffer indicating the bytes of random number requested. Return Value 0 for success -1 for failure Message Digest and MAC Functions \u00b6 crypto_hal_hash() \u00b6 int32_t crypto_hal_hash(uint8_t hash_type, const uint8_t *buffer, size_t buffer_length, uint8_t *output, size_t output_length) Description This function hashes the contents of the memory pointed to by buffer of size buffer_length with hash_type algorithm and fills the memory pointed to by output of size output_length with generated hash. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters hash_type: This function must support all the hash algorithms identifiers mentioned in FDO_CRYPTO_HASH_TYPE except FDO_CRYPTO_HASH_TYPE_SHA_512 (optional). Client SDK uses FDO_CRYPTO_HASH_TYPE_USED to decide at compile time which hash_type to use - either FDO_CRYPTO_HASH_TYPE_SHA_256 or FDO_CRYPTO_HASH_TYPE_SHA_384. buffer: a valid pointer to a memory containing data to be hashed buffer_length: size of memory pointed to by buffer output: a valid pointer to a memory which will be filled by hash output_length: size of the memory pointed to by output. It must be able to contain the generated Hash. Return Value 0 for success -1 for failure crypto_hal_hmac() \u00b6 int32_t crypto_hal_hmac(uint8_t hmac_type, const uint8_t *buffer, size_t buffer_length, uint8_t *output, size_t output_length, const uint8_t *key, size_t key_length) Description This function HMACs the contents of the memory pointed to by buffer of size buffer_length using key of size key_length , with hmac_type algorithm and fills the memory pointed to by output of size output_length with generated HMAC. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters hmac_type : This function must support all the HMAC algorithms identifiers mentioned in FDO_CRYPTO_HMAC_TYPE except FDO_CRYPTO_HMAC_TYPE_SHA_512 (optional). Client SDK uses FDO_CRYPTO_HMAC_TYPE_USED to decide at compile time which hmac_type to use - either FDO_CRYPTO_HMAC_TYPE_SHA_256 or FDO_CRYPTO_HMAC_TYPE_SHA_384. buffer: a valid pointer to a memory containing data to be HMACed. buffer_length: size of memory pointed to by buffer output: a valid pointer to a memory which will be filled by HMACed data. output_length: size of the memory pointed to by output. It must be able to contain the generated HMAC. Return Value 0 for success -1 for failure Asymmetric Functions \u00b6 crypto_hal_sig_verify() \u00b6 int32_t crypto_hal_sig_verify(uint8_t key_encoding, uint8_t key_algorithm, const uint8_t *message, uint32_t message_length, const uint8_t *message_signature, uint32_t signature_length, const uint8_t *key_param1, uint32_t key_param1Length, const uint8_t *key_param2, uint32_t key_param2Length) Description This function verifies the ECDSA signature pointed by message_signature of size message_length on the data pointed by message of size message_length with the key material key_param1 and key_param2 interpreted according to key_encoding . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters key_encoding: FDO_CRYPTO_PUB_KEY_ENCODING_COSEX509 encoding is used for ECDSA. Please refer FDO_CRYPTO_PUB_KEY_ENCODING key_algorithm: FDO_CRYPTO_PUB_KEY_ALGO_(ECDSAp256/ECDSAp384) is used for ECDSA. Please refer FDO_CRYPTO_PUB_KEY_ALGO message: data over which the sign verification needs to be performed. message_length: size of the message message_signature: signature over the message sent by the signing entity. Signature is of the form 'r' concatenated with 's' (r|s). signature_length: size of the message_signature key_param1: ECDSA key of the form Affine 'x' concatenated with Affine 'y' (X|Y) key_param1Length: size of the key in key_param1 key_param2: NULL, unused key_param2Length: size of the key in key_param2, unused Return Value 0 for success -1 for failure crypto_hal_ecdsa_sign() \u00b6 int32_t crypto_hal_ecdsa_sign(const uint8_t *message, size_t message_len, unsigned char *signature, size_t *signature_len) Description This function signs the message of size message_len and fills the signed data in signature of size signature_len . Algorithm is based on the compile time flags ECDSA256_DA and ECDSA384_DA. Signing Key is loaded from filesystem stored at location ECDSA_PRIVKEY. Signature Length is allocated by Client SDK based on internal define ECDSA_SIGNATURE_MAX_LEN. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters message: The message over which sign is to be calculated. message_length: size of the message signature: The buffer to fill signature with. Signature is of the form r concatenated with s (r|s). signature_len: size of the signature Return Value 0 for success -1 for failure Symmetric Cipher Functions \u00b6 crypto_hal_aes_encrypt() \u00b6 int32_t crypto_hal_aes_encrypt(const uint8_t *clear_text, uint32_t clear_text_length, uint8_t *cipher_text, uint32_t *cipher_length, size_t block_size, const uint8_t *iv, const uint8_t *key, uint32_t key_length, uint8_t *tag, size_t tag_length, const uint8_t *aad, size_t aad_length) Description This function encrypts the clear_text of size clear_text_length with the AES algorithm using key of size key_length and fills the cipher_text with encrypted content of size cipher_length . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters clear_text: pointer to the buffer containing text to be encrypted clear_text_length: size of clear_text cipher_text: pointer to the empty buffer to be filled after encrypting clear_text cipher_length: size of buffer pointed by cipher_text. This is IN/OUT parameter and gets filled with size of expected encrypted buffer in case cipher_text is passed as NULL with all other parameters as valid. block_size: AES block size (16 bytes) iv : Initialization Vector of size 12 bytes for AES-GCM and 7 bytes for AES-CCM. key: AES symmetric key key_length: size of the key tag: pointer to the empty buffer to be filled after generating the Authentication Tag tag_length: size of the Authentication Tag (16 bytes) aad: pointer to the buffer containing Additional Authenticated Data (AAD) aad_length: size of the Additional Authenticated Data (AAD) Return Value 0 for success -1 for failure crypto_hal_aes_decrypt() \u00b6 int32_t crypto_hal_aes_decrypt(uint8_t *clear_text, uint32_t *clear_text_length, const uint8_t *cipher_text, uint32_t cipher_length, size_t block_size, const uint8_t *iv, const uint8_t *key, uint32_t key_length, uint8_t *tag, size_t tag_length, const uint8_t *aad, size_t aad_length) Description This function decrypts the cipher_text of size cipher_length with the AES algorithm using key of size key_length and fills the clear_text with unencrypted content of length clear_text_length . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters clear_text: pointer to the empty buffer to be filled with unencrypted text clear_text_length: size of clear_text. This is IN/OUT parameter and gets filled with size of expected unencrypted buffer in case clear_text is passed as NULL with all other parameters as valid. cipher_text: pointer to the buffer containing text to be decrypted. cipher_length: size of cipher_text. block_size: AES block size (16 bytes) iv: Initialization Vector of size 12 bytes for AES-GCM and 7 bytes for AES-CCM. key: AES symmetric key key_length: size of the key tag: pointer to the buffer containing Authentication Tag to be verified tag_length: size of the Authentication Tag (16 bytes) aad: pointer to the buffer containing Additional Authenticated Data (AAD) aad_length: size of the Additional Authenticated Data (AAD) Return Value 0 for success -1 for failure Certificate Signing Request \u00b6 crypto_hal_get_device_csr() \u00b6 int32_t crypto_hal_get_device_csr(fdo_byte_array_t **csr); Description This function fills the Client SDK byte array csr with the Certificate Signing Request (CSR) data. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses the standard mbedTLS/openSSL APIs Parameters csr: FDO byte array. Please refer fdo_byte_array_t. The usage of the structure is as below: - byte_sz: size of the buffer in bytes pointed by bytes - bytes: pointer to a stream of bytes This array is allocated by using fdo_byte_array_alloc(size_of_buffer) function. Return Value 0 for success -1 for failure Key Exchange Functions \u00b6 crypto_hal_kex_init() \u00b6 int32_t crypto_hal_kex_init(void **context) Description Client SDK uses ECDH algorithm to perform key exchange for creating a secure channel between Device and Owner. The configurations are mentioned in Crypto Configuration. The Device is considered as entity B in Key Exchange and the Owner is considered as entity A. ECDH: This function creates an ECDH key pair. It then appends a random number with the public part of the generated key pair to generate a stream of bytes known as Device Random as mentioned below. ByteArray[blen(Qx), Qx, blen(Qy), Qy, blen(DeviceRandom), Random Number] The random number as mentioned above is of size 16 bytes (ECDH256) or 48 bytes (ECDH384). In the later part of Client SDK execution, this buffer is retrieved using crypto_hal_get_device_random() and sent to the owner for generating the shared secret. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters context: a valid pointer to store the key exchange context. Return Value 0 for success -1 for failure crypto_hal_kex_close() \u00b6 int32_t crypto_hal_kex_close(void \\*\\*context) Description This function tears down the key exchange context created by crypto_hal_kex_init() . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters context: a valid pointer of key exchange context. Return Value 0 for success -1 for failure crypto_hal_get_device_random() \u00b6 int32_t crypto_hal_get_device_random(void *context, uint8_t *dev_rand_value, uint32_t *dev_rand_length) Description This function fills the buffer pointed to by dev_rand_value of size dev_rand_length with the Device Random Value. The Device Random value is generated differently for different algorithms. Currently, only ECDH algorithm is supported in this release. ECDH: The buffer generated in crypto_hal_kex_init() is the Device Random. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs or internal data structures which can be reused. Parameters context: a valid pointer of key exchange context. dev_rand_value: A valid pointer to an empty buffer. If this parameter is passed as NULL, then this function returns the size of the Device Random in dev_rand_length. dev_rand_length: The size of the buffer pointed by dev_rand_value. Return Value 0 for success -1 for failure crypto_hal_set_peer_random() \u00b6 int32_t crypto_hal_set_peer_random(void *context, const uint8_t *peer_rand_value, uint32_t peer_rand_length) Description This function updates the key exchange context with peer_rand_value of size peer_rand_length . This function uses this information to generate shared secret. Currently, only ECDH algorithm is supported in this release. ECDH: The Owner sends the data in a similar buffer layout as device sends it. Please see crypto_hal_kex_init() for the device Key Exchange buffer layout. ByteArray[blen(Ax), Ax, blen(Ay), Ay, blen(OwnerRandom), OwnerRandom] This function fills the point Qp with the Owner Information and generates an ECDH key pair. The shared secret is generated as: Shx ||DeviceRandom||OwnerRandom Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters context: a valid pointer of key exchange context. peer_rand_value: a valid pointer to Owner data for generating shared secret. peer_rand_length: The size of the buffer pointed by peer_rand_value. Return Value 0 for success -1 for failure crypto_hal_get_secret() \u00b6 int32_t crypto_hal_get_secret(void *context, uint8_t *secret, uint32_t *secret_length) Description This function returns the shared secret created as part of key exchange protocol by crypto_hal_set_peer_random() . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses the internal structure members which gets filled in Key Exchange protocol. Parameters context: a valid pointer of key exchange context. secret: A valid pointer to an empty buffer. If this parameter is passed as NULL, then this function returns the size of the secret in secret_length. secret_length: The size of the buffer pointed by secret. Return Value 0 for success -1 for failure Network Subsystem API \u00b6 Networking is a platform offering which enables Client SDK to connect to Manufacturer, Rendezvous and Owner over the network. The required functionality by the Client SDK is abstracted via a set of APIs declared in file \"network/include/network_al.h\". Client SDK communicates with Manufacturer, Rendezvous and Owner using REST API. It is not a constraint on the APIs, and the APIs could well be defined to communicate over any protocol. Note This section of the document specifies the internal APIs to abstract Network implementation from Client SDK and are subject to change. Constants \u00b6 IPV4_ADDR_LEN \u00b6 #define IPV4_ADDR_LEN 4 The Client SDK uses this define for IPv4 IP address. For usage, please refer fdo_con_dns_lookup() FDO_TYPE_ERROR \u00b6 #define FDO_TYPE_ERROR 255 The Client SDK uses this to indicates an error. For usage, please refer fdo_con_recv_msg_header() Data Types \u00b6 fdo_ip_address_t \u00b6 This defines the IP address structure used to pass IP address information within Client SDK. The usage of the structure is detailed in fdo_con_dns_lookup() typedef struct { uint8_t length; uint8_t addr[16]; } fdo_ip_address_t; fdo_con_handle \u00b6 fdo_con_handle is specific to the underlying network library. In software distributions supporting POSIX, fdo_con_handle can be an int or any implementation specific datatype. For Client SDK, this is opaque data type, and it will not use its internal members. Connection Management Functions \u00b6 fdo_con_setup() \u00b6 int32_t fdo_con_setup(char *medium, char **params, uint32_t count) Description This function sets up the connection identified by medium based on the count number of params . It is expected that this call will block until the interface has been established and is stable. It may be called multiple times, and if in subsequent calls to this function, the medium value changes, the existing connection must be terminated, and a new connection must be created on new medium. If the medium is the same as used in existing connection, this function must continue to retain the previous setup connection. Medium Meaning params NULL Connect to any available network interface. NULL eth* Connect to any available Ethernet interface. NULL eth0\u20269 Connect to the specified numbered Ethernet interface. NULL wifi* Connect to any available WiFi interface. NULL wifi Connect to the WiFi SSID and password specified by params. params[0] = SSID Note In existing implementation, Client SDK calls this function with medium as NULL and params as NULL and initializes REST API handling context. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation initializes REST context which is used to communicate with Manufacturer/Rendezvous/Owner Server Parameters medium: Refer above table params: NULL or an array of NULL terminated ASCII strings required to connect to medium. count: 0 or number of NULL terminated ASCII strings in params Return Value 0 for success -1 for failure fdo_con_teardown() \u00b6 int32_t fdo_con_teardown(void) Description This function shuts down the connection established by the function described in fdo_con_setup() Note This function may not require a change in implementation for porting to custom platform, as the reference implementation tears down the REST context created in fdo_con_setup() Parameters None Return Value 0 for success -1 for failure fdo_con_dns_lookup() \u00b6 int32_t fdo_con_dns_lookup(const char *url, fdo_ip_address_t **ip_list, uint32_t *ip_list_size) Description This function performs a DNS lookup for the specified host identified by the url and return a list of IP addresses in the ip_list . Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to perform Domain Name resolution. Parameters url: NULL terminated string like \u201c192.168.0.1\u201d or \u201cexample@noname.com\u201d ip_list: Refer fdo_ip_address_t for the structure declaration. The usage of this structure is as follows: length: The value should be 4 for IPv4 and 16 for IPv6 addresses addr: specifies the IP address in network byte order ip_list_size: specifies the number of IP addresses in the ip_list. Return Value 0 for success -1 for failure fdo_con_connect() \u00b6 fdo_con_handle fdo_con_connect(fdo_ip_address_t *addr, uint16_t port, void **ssl) Description This function connects to the IP address specified in addr on the given port. If the ssl pointer is non-NULL, enable SSL on the opened socket. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to connect to the server. Parameters addr: server IP address. Please refer fdo_con_dns_lookup() port: server port to connect to ssl: NULL or valid pointer to receive the ssl context in case ssl is enabled Return Value Connection handle for success. Please refer fdo_con_handle . -1 for failure fdo_con_disconnect() \u00b6 int32_t fdo_con_disconnect(fdo_con_handle handle, void *ssl) Description This function terminates the connection associated with handle. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to disconnect from the server. Parameters handle: Valid connection handle. Please refer to fdo_con_connect() ssl: NULL or valid pointer in case, SSL connection was established. Please refer to fdo_con_connect() Return Value 0 for success -1 for failure Connection Data Management Functions \u00b6 fdo_con_recv_msg_header() \u00b6 int32_t fdo_con_recv_msg_header(fdo_con_handle handle, uint32_t *protocol_version, uint32_t *message_type, uint32_t *msglen, void *ssl) Description This function receives the message header on the specified connection handle and returns protocol_version , message_type and msglen . It will block until a message is available. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux* libraries to receive data from the server. Parameters handle: Connection handle. Please refer to fdo_con_connect() protocol_version: Incoming protocol version. Client SDK supports 113 message_type: set to FDO_TYPE_ERROR in case of error. Please refer FDO_TYPE_ERROR msglen: Length of incoming message body ssl: valid SSL context in case SSL is enabled. Please refer s do_con_connect() Return Value 0 for success -1 for failure fdo_con_recv_msg_body() \u00b6 int32_t fdo_con_recv_msg_body(fdo_con_handle handle, uint8_t *buf, size_t length, void *ssl) Description This function receives the message body on the connection specified by handle in the provided memory pointed to by buf of size length . The message received corresponds to the message header received in the immediate preceding call to fdo_con_recv_msg_header() . This function blocks unless the specified length of data is received. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux* libraries to receive data from the server. Parameters handle: Connection handle. Please refer to fdo_con_connect() buf: pointer to the empty buffer for receiving the message length: size of buf and equal to returned from fdo_con_recv_msg_header(). ssl: valid SSL context in case SSL is enabled. Please refer to fdo_con_connect() Return Value Number of bytes for success -1 for failure fdo_con_send_message() \u00b6 int32_t fdo_con_send_message(fdo_con_handle handle, uint32_t protocol_version, uint32_t message_type, const uint8_t *buf, size_t length, void *ssl) Description This function sends the data pointed by buf of size length over the connection specified by handle with protocol_version and message_type as metadata. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to send data to the server. Parameters handle: Connection handle. Please refer to fdo_con_connect() protocol_version: Client SDK supports 113 message_type: Client SDK state machine specific. To be used as is buf: pointer to the buffer containing the message to be sent length: size of buf ssl: valid SSL context in case SSL is enabled. Please refer to fdo_con_connect() Return Value 0 for success -1 for failure Network Generic Functions \u00b6 fdo_net_to_host_long() \u00b6 uint32_t fdo_net_to_host_long(uint32_t value) Description This function converts the value from network byte order to host byte order. Note This function may require a change in implementation for porting to custom platform, as the reference implementation to perform the functionality. Parameters value: unsigned integer of size 4 bytes in network byte order Return Value Unsigned integer of size 4 bytes converted to host byte order fdo_host_to_net_long() \u00b6 uint32_t fdo_host_to_net_long(uint32_t value) Description This function converts the value from host byte order to network byte order. Note This function may require a change in implementation for porting to custom platform, as the reference implementation to perform the functionality. Parameters value: unsigned integer of size 4 bytes in host byte order Return Value Unsigned integer of size 4 bytes converted to network byte order fdo_printable_to_net() \u00b6 int32_t fdo_printable_to_net(const char *src, void *addr) Description This function converts the IP address in ASCII string pointed to by src to network byte order and stores the result in addr . Note This function may require a change in implementation for porting to custom platform, as the reference implementation to perform the functionality. Parameters src: points to a character string containing an IPv4 network address in dotted-decimal format addr: output buffer to receive IPV4 network address in network byte order Return Value 1 for success -1 for failure 0 if input format is invalid Legacy Functions \u00b6 get_device_model() \u00b6 const char *get_device_model(void) Description This function either statically or dynamically generates a device model string. Note This function may require a change in implementation for porting to custom platform, as the reference implementation returns a hard-coded string. Parameters None Return Value NULL terminated ASCII string get_device_serial_number() \u00b6 const char *get_device_serial_number(void) Description This function either statically or dynamically generates a device serial number string. Note This function may require a change in implementation for porting to custom platform, as the reference implementation returns a hard-coded string. Parameters None Return Value NULL terminated ASCII string fdo_random() \u00b6 int fdo_random(void) Description This function generates a random number Note This function may require a change in implementation for porting to custom platform, as the reference implementation uses Linux libraries to perform the functionality. Parameters None Return Value A random number fdo_sleep() \u00b6 void fdo_sleep(int sec) Description This function introduces the delay for sec number of seconds Note This function may require a change in implementation for porting to custom platform, as the reference implementation uses Linux libraries to perform the functionality. Storage Subsystem API \u00b6 Storage is a platform offering which enables Client SDK to store the credentials, state of the Client device on the storage medium. The required functionality by the Client SDK is abstracted via a set of APIs declared in file \"storage/include/storage_al.h\". Note This section of the document specifies the internal APIs to abstract Storage implementation from Client SDK and are subject to change. Constants \u00b6 fdo_sdk_blob_flags \u00b6 This enum defines the supported storage hierarchy by the API typedef enum { FDO_SDK_SECURE_DATA = 1, FDO_SDK_NORMAL_DATA = 2, FDO_SDK_OTP_DATA = 4, FDO_SDK_RAW_DATA = 8 } fdo_sdk_blob_flags; Enum Description FDO_SDK_SECURE_DATA This flag indicates to the storage API that the data is Authenticated Encrypted. As an example, the algorithm used could be AES-GCM or AES + HMAC to support this mode FDO_SDK_NORMAL_DATA This flag indicates to the storage API that the data contains Authentication information. As an example, the data is stored along with its HMAC FDO_SDK_OTP_DATA This flag indicates to the storage API that the data resides in One Time Programmable memory, so, essentially, only 1 write is possible. FDO_SDK_RAW_DATA This flag indicates to the storage API that the data is plaintext Data Types \u00b6 There are no specific data types for Storage APIs Blob Functions \u00b6 fdo_blob_read() \u00b6 int32_t fdo_blob_read(const char *blob_name, fdo_sdk_blob_flags flags, uint8_t *buffer, uint32_t length) Description This function reads the data into the buffer of size length from the blob identified by blob_name whose storage properties match with the flags . Before reading the data from blob into the buffer , it is recommended to use fdo_blob_size() to allocate the exact length of buffer . Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure storage requirements for your device, refer to the Client SDK Security Implications document. Parameters blob_name: NULL terminated string identifying the existing blob flags: Please refer fdo_sdk_blob_flags buffer: empty buffer to read the blob data length: size of buffer Return Value Number of bytes read for success -1 for failure fdo_blob_write() \u00b6 int32_t fdo_blob_write(const char *blob_name, fdo_sdk_blob_flags flags, const uint8_t *buffer, uint32_t length) Description This function writes the data from buffer of size length to the blob identified by blob_name whose storage properties are identified with the flags . This function must create the blob if it doesn\u2019t exist, otherwise, overwrite the blob. Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure storage requirements for your device, refer to the Client SDK Security Implications document. Parameters blob_name: NULL terminated string identifying the blob to be created flags: Please refer fdo_sdk_blob_flags buffer: data to be stored in the blob length: size of the data to be stored into the blob Return Value Number of bytes written for success -1 for failure fdo_blob_size() \u00b6 size_t fdo_blob_size(const char *blob_name, fdo_sdk_blob_flags flags) Description This function returns the size of blob identified by blob_name whose storage properties match with the flags . This should be used before fdo_blob_read() Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure storage requirements for your device, refer to the Client SDK Security Implications document. Parameters blob_name: NULL terminated string identifying the existing blob flags: Please refer fdo_sdk_blob_flags Return Value Blob size for success file size on success 0 if file does not exist or in case of failure","title":"Client SDK Porting Guide"},{"location":"client-sdk/client-sdk-porting-guide/#porting-guide","text":"This document provides a guide to porting the Client SDK to new platforms.","title":"Porting Guide"},{"location":"client-sdk/client-sdk-porting-guide/#solution-architecture","text":"The Client SDK reference solution is comprised of 3 layers: Application : The reference application which triggers the Device Initialization and Ownership Transfer State Machine. Library : The Device Initialization and Ownership Transfer Protocol implementation for FIDO Device Onboard Proposed Standard. Platform : Platform-specific implementation. The Platform layer is itself comprised of three modules: Crypto, Network, and Storage: Crypto : Implementation of Cryptographic requirements of Ownership Transfer Protocol. This also abstracts the \u201cPlatform\u201d specific crypto methods from the \u201cLibrary\u201d. So, the crypto implementation is divided into: Library specific implementation: There is no impact of adding new platform Platform specific implementation: The impact of adding new platform is detailed in Crypto Subsystem API section below. Network : Implementation of Networking. This abstracts the \u201cPlatform\u201d specific networking functionality from \u201cLibrary\u201d. The impact of adding new platform is detailed in the Network Subsystem API section below. Storage : Implementation of Secure Storage. This abstracts the \u201cPlatform\u201d specific storage methods from \u201cLibrary\u201d. The impact of adding new platform is detailed in the Storage Subsystem API section below.","title":"Solution Architecture"},{"location":"client-sdk/client-sdk-porting-guide/#code-structure","text":"The Client SDK reference implementation source code is organized as follows (folders that are discussed in this porting guide are indicated with \"*\"): \u251c\u2500\u2500 app - - - - - - Reference Application \u251c\u2500\u2500 crypto* - - - - Crypto Subsystem \u251c\u2500\u2500 cmake* - - - - - cmake sub files \u251c\u2500\u2500 data - - - - - - Filesystem place to store blob like keys, network info. \u251c\u2500\u2500 device_modules - ServiceInfo Modules \u251c\u2500\u2500 docs - - - - - - Documents \u251c\u2500\u2500 include - - - - Client SDK APIs \u251c\u2500\u2500 lib - - - - - - The core protocol implementation \u251c\u2500\u2500 mbedos - - - - - mbedos based Client SDK implementation \u251c\u2500\u2500 network* - - - - Network subsystem \u251c\u2500\u2500 NOTICES - - - - License specific information \u251c\u2500\u2500 storage* - - - - Storage Subsystem \u2514\u2500\u2500 utils - - - - - Reference files for setting up TPM, flashing etc.","title":"Code Structure"},{"location":"client-sdk/client-sdk-porting-guide/#build-system","text":"Starting with release v1.9.0 of the Client SDK, the build system uses cmake. This section explains the most prominent configurations in build system. The reference application is tightly coupled with the build system, storage and crypto APIs. The intent of this section is to cover those specific bindings to make the solution easy to traverse. \u251c\u2500\u2500 app \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 cmake \u2502 \u251c\u2500\u2500 blob_path.cmake \u2502 \u251c\u2500\u2500 cli_input.cmake \u2502 \u251c\u2500\u2500 extension.cmake \u2502 \u2514\u2500\u2500 pristine.cmake \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 crypto \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 device_modules \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 mbedos \u2502 \u2514\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 network \u2502 \u2514\u2500\u2500 CMakeLists.txt \u2514\u2500\u2500 storage \u2514\u2500\u2500 CMakeLists.txt","title":"Build System"},{"location":"client-sdk/client-sdk-porting-guide/#cli_inputcmake-erstwhile-basemk","text":"The base.mk was used to define the build flags as a top-level configuration Makefile. The cli_input.cmake still retains that property, however, the blob specific configuration is moved to blob_path.cmake. The following specifies the default build configuration which can be overridden in invocation of cmake. set (TARGET_OS linux) set (CSTD c99) set (TLS openssl) set (DA ecdsa384) set (AES_MODE gcm) set (BUILD debug) set (TARGET_OS linux) set (HTTPPROXY true) set (PROXY_DISCOVERY false) set (OPTIMIZE 1) set (DA_FILE der) set (CRYPTO_HW false) set (ARCH x86) set (RETRY true) set (unit-test false) set (STORAGE true) set (BOARD NUCLEO_F767ZI) set (BLOB_PATH .) set (TPM2_TCTI_TYPE tabrmd) set (RESALE true) set (REUSE true)","title":"cli_input.cmake (erstwhile base.mk)"},{"location":"client-sdk/client-sdk-porting-guide/#blob_pathcmake","text":"The blob specific paths are set with this cmake file. A new variable BLOB_PATH is introduced to customize the placement of blobs in the filesystem. client_sdk_compile_definitions( -DSERIAL_FILE=\\\"${BLOB_PATH}/data/manufacturer_sn.bin\\\" -DMODEL_FILE=\\\"${BLOB_PATH}/data/manufacturer_mod.bin\\\" -DPLATFORM_IV=\\\"${BLOB_PATH}/data/platform_iv.bin\\\" -DPLATFORM_HMAC_KEY=\\\"${BLOB_PATH}/data/platform_hmac_key.bin\\\" -DPLATFORM_AES_KEY=\\\"${BLOB_PATH}/data/platform_aes_key.bin\\\" -DEPID_PRIVKEY=\\\"${BLOB_PATH}/data/epidprivkey.dat\\\" -DFDO_CRED=\\\"${BLOB_PATH}/data/PMDeviceCredentials.bin\\\" -DMANUFACTURER_ADDR=\\\"${BLOB_PATH}/data/manufacturer_addr.bin\\\" -DMAX_SERVICEINFO_SZ_FILE=\\\"${BLOB_PATH}/data/max_serviceinfo_sz.bin\\\" ) client_sdk_compile_definitions( -DFDO_CACERT=\\\"${BLOB_PATH}/data/cacert.bin\\\" -DFDO_PUBKEY=\\\"${BLOB_PATH}/data/pubkey.dat\\\" -DFDO_SIGRL=\\\"${BLOB_PATH}/data/sigrl.dat\\\" -DFDO_CRED_SECURE=\\\"${BLOB_PATH}/data/Secure.blob\\\" -DFDO_CRED_MFG=\\\"${BLOB_PATH}/data/Mfg.blob\\\" -DFDO_CRED_NORMAL=\\\"${BLOB_PATH}/data/Normal.blob\\\" )","title":"blob_path.cmake"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_cred_normal-normalblob","text":"The Client SDK or Device lifecycle is maintained in this blob. This data is stored as Authenticated Data meaning that HMAC256 is calculated over this data and stored back. Note This is part of custom storage implementation in reference solution. Please refer Storage Subsystem API for details required for implementation on custom platform. The Application may use APIs listed in Storage Subsystem API, to manipulate blobs, so, the blobs remain consistent as expected by Client SDK. However, the APIs mentioned in the above said section are internal APIs and it is up to the application developer to reuse them. The application, before starting the state machine by calling fdo_sdk_init() generates the HMAC over this data and stores it back along with the data. This is initialized to the following value to indicate that the device is in manufactured state. It also allows the reference application to perform multiple cycles of FIDO Device Onboard operation. blob_path.cmake: file(WRITE ${BLOB_PATH}/data/Normal.blob \"{\\\"ST\\\":1}\")","title":"FDO_CRED_NORMAL - Normal.blob"},{"location":"client-sdk/client-sdk-porting-guide/#platform_ivhmac_keyaes_key","text":"The purpose of these defines is to specify the location where the reference solution stores the following information: PLATFORM_IV: Initialization Vector used in Authenticated Encryption of Secure Blobs. The Secure Blobs are internal to Client SDK and are not controlled by the application. PLATFORM_HMAC_KEY: HMAC key to authenticate Normal.blob or any other internal blob which only needs Authenticated read. PLATFORM_AES_KEY: AES key to Authenticate Encrypt the Secure Blobs. The Secure Blobs are internal to Client SDK and are not controlled by the application. Note These flags are not necessary for the platforms which have their own Secure Storage mechanisms. The platform may be able to store all blobs using Authenticated Encryption including Normal.blob. Client SDK always uses fdo_blob_read() to read the data, so, the underlying detail is already abstracted. In the reference solution, it is expected that these files exist physically although without any content. The content gets generated on an as-needed basis.","title":"PLATFORM_(IV/HMAC_KEY/AES_KEY)"},{"location":"client-sdk/client-sdk-porting-guide/#manufacturer_addr","text":"Client SDK uses the location defined in the specified file to connect to Manufacturer Server to perform Device Initialization. The format for the Manufacturer Address is of the form: {http,https}://{DNS,IP}:port . The following rules apply while setting the value and all of these are mandatory: The transport protocol value must be either http or https (case-sensitive). Any other value will result in an error. Either one of DNS or IP Address can be provided. The maximum value of DNS is 100 characters and must only contain alphanumeric characters (0-9A-za-z), hyphens (-) and dot (.). The port should be an integer between (1-65535). The URL separators :// and : should be present at appropriate indices as per the indices of the above values.","title":"MANUFACTURER_ADDR"},{"location":"client-sdk/client-sdk-porting-guide/#max_serviceinfo_sz_file","text":"Client SDK uses the value contained in the file path as defined by this flag, to decide the maximum ServiceInfo size the Device can process. The value must lie between 256 and 8192 (both inclusive). If the set value is less than 256, the value would default to 256. Similarly, if the value is greater than 8192, the value would default to 8192.","title":"MAX_SERVICEINFO_SZ_FILE"},{"location":"client-sdk/client-sdk-porting-guide/#ecdsa_privkey","text":"This specifies the ECDSA private key to be used as a device identity. Two options are possible: The key could be pre-created like the reference application. If the device supports secure storage, then the key can be generated within the device and stored using secure storage APIs Note This section is not a recommendation, but specifies some of the possibilities that exist.","title":"ECDSA_PRIVKEY"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_cred_securemfg","text":"These defines are used internally by Client SDK: FDO_CRED_SECURE: This define specifies the location of the device secret. This blob is Authenticated Encrypted in the reference solution. FDO_CRED_MFG: This define specifies the location of Manufacturer data. This blob is stored with Authenticated information.","title":"FDO_CRED_(SECURE/MFG)"},{"location":"client-sdk/client-sdk-porting-guide/#extensioncmake-erstwhile-cryptoconf","text":"This cmake file consists mostly of build configuration from crypto.conf but is not limited to it.","title":"extension.cmake (erstwhile crypto.conf)"},{"location":"client-sdk/client-sdk-porting-guide/#supported-configurations","text":"The following content is retained from crypto.conf for readability. ### Device Attestation validation SUPPORTED_DA = ecdsa256 ecdsa384 tpm20_ecdsa256 ### AES mode for secure channel SUPPORTED_AES_MODE = gcm ccm SUPPORTED_DA: This specifies the supported Device Attestation algorithms which device uses to prove its identity to Rendezvous Server and Owner. This automatically configures the Key Exchange algorithm (ECDH256/ECDH384) that is used to generate the shared secret and the AES Mode, to use higher crypto in the source. Note tpm20_ecdsa256 isn\u2019t a separate algorithm, it uses ecdsa256 as Device Attestation, but uses TPM2.0 to generate keys and store data Note The Public Key Encoding supported in COSEX509. SUPPORTED_AES_MODE: This specifies the AES mode of encryption supported by device. The device supports GCM and CCM. The following configurations are supported as per the Device Attestation algorithm: A128GCM, A256GCM, AES-CCM-64-128-128 and AES-CCM-64-128-256.","title":"Supported Configurations"},{"location":"client-sdk/client-sdk-porting-guide/#client-sdk-constants","text":"","title":"Client SDK Constants"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_error","text":"typedef enum { FDO_RV_TIMEOUT = 1, FDO_CONN_TIMEOUT, FDO_DI_ERROR, FDO_TO1_ERROR, FDO_TO2_ERROR } fdo_sdk_error; The usage of this enum is detailed in fdo_sdk_init()","title":"fdo_sdk_error"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_status","text":"typedef enum { FDO_SUCCESS, FDO_INVALID_PATH, FDO_CONFIG_NOT_FOUND, FDO_INVALID_STATE, FDO_RESALE_NOT_SUPPORTED, FDO_RESALE_NOT_READY, FDO_WARNING, FDO_ERROR, FDO_ABORT } fdo_sdk_status; The usage of this enum is detailed in fdo_sdk_init()","title":"fdo_sdk_status"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_device_state","text":"typedef enum { FDO_STATE_PRE_DI = 2, FDO_STATE_PRE_TO1, FDO_STATE_IDLE, FDO_STATE_RESALE, FDO_STATE_ERROR } fdo_sdk_device_state; The usage of this enum is detailed in fdo_sdk_get_status()","title":"fdo_sdk_device_state"},{"location":"client-sdk/client-sdk-porting-guide/#client-sdk-functions","text":"The application resides in the app directory of the reference solution. The application uses the APIs specified in include/fdo.h to trigger the Ownership transfer state machine. The following lists the APIs which the application uses to perform Device Initialization or start Ownership Transfer Protocol.","title":"Client SDK Functions"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_init","text":"fdo_sdk_status fdo_sdk_init(fdo_sdk_errorCB error_handling_callback, uint32_t num_modules, fdo_sdk_service_info_module *module_information); typedef int (*fdo_sdk_errorCB)(fdo_sdk_status type, fdo_sdk_error error_code); Description This function initializes the Client SDK data structures. It allows the application to control the error handling of the Client SDK state machine by setting error_handling_callback. Client SDK calls error_handling_callback to propagate the error_code(fdo_sdk_error) back to the application with Client SDK internal status fdo_sdk_status(fdo_sdk_status). The application may handle the error and return the appropriate action to be taken by Client SDK further. Note The reference application allows the Client SDK to retry 5 times before calling abort The Client SDK allows the owner to download the required Device Management System agents via ServiceInfo mechanism; the num_modules and module_information registers the ServiceInfo modules with the Client SDK. Parameters error_handling_callback: It is of type fdo_sdk_errorCB num_modules: number of ServiceInfo modules to register. module_information: Array of ServiceInfo modules registration information Return Value FDO_SUCCESS for success. Greater than FDO_SUCCESS for failure (refer fdo_sdk_status)","title":"fdo_sdk_init()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_run","text":"fdo_sdk_status fdo_sdk_run(void); Description This function triggers either the Device Initialize state machine or Ownership Transfer Protocol state machine depending on the device status stored in Normal.blob. Note The reference application's first successful execution performs Device Initialization. The second execution begins to perform Ownership Transfer Protocol. Parameters None Return Value FDO_SUCCESS for success. Greater than FDO_SUCCESS for failure (refer fdo_sdk_status)","title":"fdo_sdk_run()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_resale","text":"fdo_sdk_status fdo_sdk_resale(void); Description This function triggers the device resale. Parameters None Return Value FDO_SUCCESS for success. Greater than FDO_SUCCESS for failure (refer fdo_sdk_status)","title":"fdo_sdk_resale()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_get_status","text":"fdo_sdk_device_state fdo_sdk_get_status(void); Description This function returns the current state of the device. Parameters None Return Value Please refer fdo_sdk_status: FDO_STATE_PRE_DI: Device is ready for DI FDO_STATE_PRE_TO1: Device is ready for Ownership transfer FDO_STATE_IDLE: Device's ownership transfer done FDO_STATE_RESALE: Device is ready for ownership transfer FDO_STATE_ERROR: Error in getting device status","title":"fdo_sdk_get_status()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto-subsystem-api","text":"Cryptography support is a platform offering which enables Client SDK to generate random number, perform encryption, signing, sign verification and so on. The required functionality by the Client SDK is abstracted via a set of APIs declared in file \"crypto/include/fdoCryptoHal.h\" and \"crypto/include/base64.h\" Note This section of the document specifies the internal APIs to abstract Crypto implementation from Client SDK and are subject to change.","title":"Crypto Subsystem API"},{"location":"client-sdk/client-sdk-porting-guide/#constants","text":"","title":"Constants"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_crypto_hash_type","text":"#define FDO_CRYPTO_HASH_TYPE_SHA_256 -16 #define FDO_CRYPTO_HASH_TYPE_SHA_384 -43 The usage of this define is detailed in crypto_hal_hash() .","title":"FDO_CRYPTO_HASH_TYPE"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_crypto_hmac_type","text":"#define FDO_CRYPTO_HMAC_TYPE_SHA_256 5 #define FDO_CRYPTO_HMAC_TYPE_SHA_384 6 The usage of this define is detailed in crypto_hal_hmac() .","title":"FDO_CRYPTO_HMAC_TYPE"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_crypto_pub_key_encoding","text":"#define FDO_CRYPTO_PUB_KEY_ENCODING_COSEX509 2 The usage of this define is detailed in crypto_hal_sig_verify() .","title":"FDO_CRYPTO_PUB_KEY_ENCODING"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_crypto_pub_key_algo","text":"#define FDO_CRYPTO_PUB_KEY_ALGO_ECDSAp256 -7 #define FDO_CRYPTO_PUB_KEY_ALGO_ECDSAp384 -35 The usage of this define is detailed in crypto_hal_sig_verify() .","title":"FDO_CRYPTO_PUB_KEY_ALGO"},{"location":"client-sdk/client-sdk-porting-guide/#structures","text":"","title":"Structures"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_byte_array_t","text":"typedef struct { size_t byte_sz; uint8_t * bytes; } fdo_bits_t; typedef fdo_bits_t fdo_byte_array_t; The usage is detailed in crypto_hal_get_device_csr() .","title":"fdo_byte_array_t"},{"location":"client-sdk/client-sdk-porting-guide/#initialization-and-exit-functions","text":"","title":"Initialization and Exit Functions"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_init","text":"int32_t crypto_init(void) Description This function initializes and enables the crypto services to be used by Client SDK. Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure random number generation requirements for your device, refer to the Client SDK Security Implications document. Parameters None Return Value 0 for success -1 for failure","title":"crypto_init()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_close","text":"int32_t crypto_close(void) Description This function tears down any initialization done to enable crypto services to Client SDK. Note This function may require a change in implementation for porting to custom platform, as it tears down the initialization done in crypto_init() . Also, the crypto tear down could be different for custom platforms. Parameters None Return Value 0 for success -1 for failure","title":"crypto_close()"},{"location":"client-sdk/client-sdk-porting-guide/#random-number-functions","text":"","title":"Random Number Functions"},{"location":"client-sdk/client-sdk-porting-guide/#random_init","text":"int random_init(void) Description This function initializes the random number generator functionality. Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure random number generation requirements for your device, refer to the Client SDK Security Implications document. Parameters None Return Value 0 for success -1 for failure","title":"random_init()"},{"location":"client-sdk/client-sdk-porting-guide/#random_close","text":"int random_close(void) Description This function releases the random number context. After this call, the random number cannot be retrieved from a call to crypto_hal_random_bytes() Note This function may require a change in implementation for porting to custom platform, as it tears down the initialization done to setup random number generator which may be different in custom platform Parameters None Return Value 0 for success -1 for failure","title":"random_close()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_random_bytes","text":"int32_t crypto_hal_random_bytes(uint8_t *random_buffer, size_t num_bytes) Description This function fills the random_buffer with the random number of size num_bytes. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters random_buffer: pointer to memory to receive random number num_bytes: size of memory pointed by random_buffer indicating the bytes of random number requested. Return Value 0 for success -1 for failure","title":"crypto_hal_random_bytes()"},{"location":"client-sdk/client-sdk-porting-guide/#message-digest-and-mac-functions","text":"","title":"Message Digest and MAC Functions"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_hash","text":"int32_t crypto_hal_hash(uint8_t hash_type, const uint8_t *buffer, size_t buffer_length, uint8_t *output, size_t output_length) Description This function hashes the contents of the memory pointed to by buffer of size buffer_length with hash_type algorithm and fills the memory pointed to by output of size output_length with generated hash. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters hash_type: This function must support all the hash algorithms identifiers mentioned in FDO_CRYPTO_HASH_TYPE except FDO_CRYPTO_HASH_TYPE_SHA_512 (optional). Client SDK uses FDO_CRYPTO_HASH_TYPE_USED to decide at compile time which hash_type to use - either FDO_CRYPTO_HASH_TYPE_SHA_256 or FDO_CRYPTO_HASH_TYPE_SHA_384. buffer: a valid pointer to a memory containing data to be hashed buffer_length: size of memory pointed to by buffer output: a valid pointer to a memory which will be filled by hash output_length: size of the memory pointed to by output. It must be able to contain the generated Hash. Return Value 0 for success -1 for failure","title":"crypto_hal_hash()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_hmac","text":"int32_t crypto_hal_hmac(uint8_t hmac_type, const uint8_t *buffer, size_t buffer_length, uint8_t *output, size_t output_length, const uint8_t *key, size_t key_length) Description This function HMACs the contents of the memory pointed to by buffer of size buffer_length using key of size key_length , with hmac_type algorithm and fills the memory pointed to by output of size output_length with generated HMAC. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters hmac_type : This function must support all the HMAC algorithms identifiers mentioned in FDO_CRYPTO_HMAC_TYPE except FDO_CRYPTO_HMAC_TYPE_SHA_512 (optional). Client SDK uses FDO_CRYPTO_HMAC_TYPE_USED to decide at compile time which hmac_type to use - either FDO_CRYPTO_HMAC_TYPE_SHA_256 or FDO_CRYPTO_HMAC_TYPE_SHA_384. buffer: a valid pointer to a memory containing data to be HMACed. buffer_length: size of memory pointed to by buffer output: a valid pointer to a memory which will be filled by HMACed data. output_length: size of the memory pointed to by output. It must be able to contain the generated HMAC. Return Value 0 for success -1 for failure","title":"crypto_hal_hmac()"},{"location":"client-sdk/client-sdk-porting-guide/#asymmetric-functions","text":"","title":"Asymmetric Functions"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_sig_verify","text":"int32_t crypto_hal_sig_verify(uint8_t key_encoding, uint8_t key_algorithm, const uint8_t *message, uint32_t message_length, const uint8_t *message_signature, uint32_t signature_length, const uint8_t *key_param1, uint32_t key_param1Length, const uint8_t *key_param2, uint32_t key_param2Length) Description This function verifies the ECDSA signature pointed by message_signature of size message_length on the data pointed by message of size message_length with the key material key_param1 and key_param2 interpreted according to key_encoding . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters key_encoding: FDO_CRYPTO_PUB_KEY_ENCODING_COSEX509 encoding is used for ECDSA. Please refer FDO_CRYPTO_PUB_KEY_ENCODING key_algorithm: FDO_CRYPTO_PUB_KEY_ALGO_(ECDSAp256/ECDSAp384) is used for ECDSA. Please refer FDO_CRYPTO_PUB_KEY_ALGO message: data over which the sign verification needs to be performed. message_length: size of the message message_signature: signature over the message sent by the signing entity. Signature is of the form 'r' concatenated with 's' (r|s). signature_length: size of the message_signature key_param1: ECDSA key of the form Affine 'x' concatenated with Affine 'y' (X|Y) key_param1Length: size of the key in key_param1 key_param2: NULL, unused key_param2Length: size of the key in key_param2, unused Return Value 0 for success -1 for failure","title":"crypto_hal_sig_verify()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_ecdsa_sign","text":"int32_t crypto_hal_ecdsa_sign(const uint8_t *message, size_t message_len, unsigned char *signature, size_t *signature_len) Description This function signs the message of size message_len and fills the signed data in signature of size signature_len . Algorithm is based on the compile time flags ECDSA256_DA and ECDSA384_DA. Signing Key is loaded from filesystem stored at location ECDSA_PRIVKEY. Signature Length is allocated by Client SDK based on internal define ECDSA_SIGNATURE_MAX_LEN. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters message: The message over which sign is to be calculated. message_length: size of the message signature: The buffer to fill signature with. Signature is of the form r concatenated with s (r|s). signature_len: size of the signature Return Value 0 for success -1 for failure","title":"crypto_hal_ecdsa_sign()"},{"location":"client-sdk/client-sdk-porting-guide/#symmetric-cipher-functions","text":"","title":"Symmetric Cipher Functions"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_aes_encrypt","text":"int32_t crypto_hal_aes_encrypt(const uint8_t *clear_text, uint32_t clear_text_length, uint8_t *cipher_text, uint32_t *cipher_length, size_t block_size, const uint8_t *iv, const uint8_t *key, uint32_t key_length, uint8_t *tag, size_t tag_length, const uint8_t *aad, size_t aad_length) Description This function encrypts the clear_text of size clear_text_length with the AES algorithm using key of size key_length and fills the cipher_text with encrypted content of size cipher_length . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters clear_text: pointer to the buffer containing text to be encrypted clear_text_length: size of clear_text cipher_text: pointer to the empty buffer to be filled after encrypting clear_text cipher_length: size of buffer pointed by cipher_text. This is IN/OUT parameter and gets filled with size of expected encrypted buffer in case cipher_text is passed as NULL with all other parameters as valid. block_size: AES block size (16 bytes) iv : Initialization Vector of size 12 bytes for AES-GCM and 7 bytes for AES-CCM. key: AES symmetric key key_length: size of the key tag: pointer to the empty buffer to be filled after generating the Authentication Tag tag_length: size of the Authentication Tag (16 bytes) aad: pointer to the buffer containing Additional Authenticated Data (AAD) aad_length: size of the Additional Authenticated Data (AAD) Return Value 0 for success -1 for failure","title":"crypto_hal_aes_encrypt()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_aes_decrypt","text":"int32_t crypto_hal_aes_decrypt(uint8_t *clear_text, uint32_t *clear_text_length, const uint8_t *cipher_text, uint32_t cipher_length, size_t block_size, const uint8_t *iv, const uint8_t *key, uint32_t key_length, uint8_t *tag, size_t tag_length, const uint8_t *aad, size_t aad_length) Description This function decrypts the cipher_text of size cipher_length with the AES algorithm using key of size key_length and fills the clear_text with unencrypted content of length clear_text_length . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters clear_text: pointer to the empty buffer to be filled with unencrypted text clear_text_length: size of clear_text. This is IN/OUT parameter and gets filled with size of expected unencrypted buffer in case clear_text is passed as NULL with all other parameters as valid. cipher_text: pointer to the buffer containing text to be decrypted. cipher_length: size of cipher_text. block_size: AES block size (16 bytes) iv: Initialization Vector of size 12 bytes for AES-GCM and 7 bytes for AES-CCM. key: AES symmetric key key_length: size of the key tag: pointer to the buffer containing Authentication Tag to be verified tag_length: size of the Authentication Tag (16 bytes) aad: pointer to the buffer containing Additional Authenticated Data (AAD) aad_length: size of the Additional Authenticated Data (AAD) Return Value 0 for success -1 for failure","title":"crypto_hal_aes_decrypt()"},{"location":"client-sdk/client-sdk-porting-guide/#certificate-signing-request","text":"","title":"Certificate Signing Request"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_get_device_csr","text":"int32_t crypto_hal_get_device_csr(fdo_byte_array_t **csr); Description This function fills the Client SDK byte array csr with the Certificate Signing Request (CSR) data. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses the standard mbedTLS/openSSL APIs Parameters csr: FDO byte array. Please refer fdo_byte_array_t. The usage of the structure is as below: - byte_sz: size of the buffer in bytes pointed by bytes - bytes: pointer to a stream of bytes This array is allocated by using fdo_byte_array_alloc(size_of_buffer) function. Return Value 0 for success -1 for failure","title":"crypto_hal_get_device_csr()"},{"location":"client-sdk/client-sdk-porting-guide/#key-exchange-functions","text":"","title":"Key Exchange Functions"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_kex_init","text":"int32_t crypto_hal_kex_init(void **context) Description Client SDK uses ECDH algorithm to perform key exchange for creating a secure channel between Device and Owner. The configurations are mentioned in Crypto Configuration. The Device is considered as entity B in Key Exchange and the Owner is considered as entity A. ECDH: This function creates an ECDH key pair. It then appends a random number with the public part of the generated key pair to generate a stream of bytes known as Device Random as mentioned below. ByteArray[blen(Qx), Qx, blen(Qy), Qy, blen(DeviceRandom), Random Number] The random number as mentioned above is of size 16 bytes (ECDH256) or 48 bytes (ECDH384). In the later part of Client SDK execution, this buffer is retrieved using crypto_hal_get_device_random() and sent to the owner for generating the shared secret. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters context: a valid pointer to store the key exchange context. Return Value 0 for success -1 for failure","title":"crypto_hal_kex_init()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_kex_close","text":"int32_t crypto_hal_kex_close(void \\*\\*context) Description This function tears down the key exchange context created by crypto_hal_kex_init() . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters context: a valid pointer of key exchange context. Return Value 0 for success -1 for failure","title":"crypto_hal_kex_close()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_get_device_random","text":"int32_t crypto_hal_get_device_random(void *context, uint8_t *dev_rand_value, uint32_t *dev_rand_length) Description This function fills the buffer pointed to by dev_rand_value of size dev_rand_length with the Device Random Value. The Device Random value is generated differently for different algorithms. Currently, only ECDH algorithm is supported in this release. ECDH: The buffer generated in crypto_hal_kex_init() is the Device Random. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs or internal data structures which can be reused. Parameters context: a valid pointer of key exchange context. dev_rand_value: A valid pointer to an empty buffer. If this parameter is passed as NULL, then this function returns the size of the Device Random in dev_rand_length. dev_rand_length: The size of the buffer pointed by dev_rand_value. Return Value 0 for success -1 for failure","title":"crypto_hal_get_device_random()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_set_peer_random","text":"int32_t crypto_hal_set_peer_random(void *context, const uint8_t *peer_rand_value, uint32_t peer_rand_length) Description This function updates the key exchange context with peer_rand_value of size peer_rand_length . This function uses this information to generate shared secret. Currently, only ECDH algorithm is supported in this release. ECDH: The Owner sends the data in a similar buffer layout as device sends it. Please see crypto_hal_kex_init() for the device Key Exchange buffer layout. ByteArray[blen(Ax), Ax, blen(Ay), Ay, blen(OwnerRandom), OwnerRandom] This function fills the point Qp with the Owner Information and generates an ECDH key pair. The shared secret is generated as: Shx ||DeviceRandom||OwnerRandom Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses standard mbedTLS/openSSL APIs Parameters context: a valid pointer of key exchange context. peer_rand_value: a valid pointer to Owner data for generating shared secret. peer_rand_length: The size of the buffer pointed by peer_rand_value. Return Value 0 for success -1 for failure","title":"crypto_hal_set_peer_random()"},{"location":"client-sdk/client-sdk-porting-guide/#crypto_hal_get_secret","text":"int32_t crypto_hal_get_secret(void *context, uint8_t *secret, uint32_t *secret_length) Description This function returns the shared secret created as part of key exchange protocol by crypto_hal_set_peer_random() . Note This function may not require a change in implementation for porting to custom platform, as the reference implementation uses the internal structure members which gets filled in Key Exchange protocol. Parameters context: a valid pointer of key exchange context. secret: A valid pointer to an empty buffer. If this parameter is passed as NULL, then this function returns the size of the secret in secret_length. secret_length: The size of the buffer pointed by secret. Return Value 0 for success -1 for failure","title":"crypto_hal_get_secret()"},{"location":"client-sdk/client-sdk-porting-guide/#network-subsystem-api","text":"Networking is a platform offering which enables Client SDK to connect to Manufacturer, Rendezvous and Owner over the network. The required functionality by the Client SDK is abstracted via a set of APIs declared in file \"network/include/network_al.h\". Client SDK communicates with Manufacturer, Rendezvous and Owner using REST API. It is not a constraint on the APIs, and the APIs could well be defined to communicate over any protocol. Note This section of the document specifies the internal APIs to abstract Network implementation from Client SDK and are subject to change.","title":"Network Subsystem API"},{"location":"client-sdk/client-sdk-porting-guide/#constants_1","text":"","title":"Constants"},{"location":"client-sdk/client-sdk-porting-guide/#ipv4_addr_len","text":"#define IPV4_ADDR_LEN 4 The Client SDK uses this define for IPv4 IP address. For usage, please refer fdo_con_dns_lookup()","title":"IPV4_ADDR_LEN"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_type_error","text":"#define FDO_TYPE_ERROR 255 The Client SDK uses this to indicates an error. For usage, please refer fdo_con_recv_msg_header()","title":"FDO_TYPE_ERROR"},{"location":"client-sdk/client-sdk-porting-guide/#data-types","text":"","title":"Data Types"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_ip_address_t","text":"This defines the IP address structure used to pass IP address information within Client SDK. The usage of the structure is detailed in fdo_con_dns_lookup() typedef struct { uint8_t length; uint8_t addr[16]; } fdo_ip_address_t;","title":"fdo_ip_address_t"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_handle","text":"fdo_con_handle is specific to the underlying network library. In software distributions supporting POSIX, fdo_con_handle can be an int or any implementation specific datatype. For Client SDK, this is opaque data type, and it will not use its internal members.","title":"fdo_con_handle"},{"location":"client-sdk/client-sdk-porting-guide/#connection-management-functions","text":"","title":"Connection Management Functions"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_setup","text":"int32_t fdo_con_setup(char *medium, char **params, uint32_t count) Description This function sets up the connection identified by medium based on the count number of params . It is expected that this call will block until the interface has been established and is stable. It may be called multiple times, and if in subsequent calls to this function, the medium value changes, the existing connection must be terminated, and a new connection must be created on new medium. If the medium is the same as used in existing connection, this function must continue to retain the previous setup connection. Medium Meaning params NULL Connect to any available network interface. NULL eth* Connect to any available Ethernet interface. NULL eth0\u20269 Connect to the specified numbered Ethernet interface. NULL wifi* Connect to any available WiFi interface. NULL wifi Connect to the WiFi SSID and password specified by params. params[0] = SSID Note In existing implementation, Client SDK calls this function with medium as NULL and params as NULL and initializes REST API handling context. Note This function may not require a change in implementation for porting to custom platform, as the reference implementation initializes REST context which is used to communicate with Manufacturer/Rendezvous/Owner Server Parameters medium: Refer above table params: NULL or an array of NULL terminated ASCII strings required to connect to medium. count: 0 or number of NULL terminated ASCII strings in params Return Value 0 for success -1 for failure","title":"fdo_con_setup()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_teardown","text":"int32_t fdo_con_teardown(void) Description This function shuts down the connection established by the function described in fdo_con_setup() Note This function may not require a change in implementation for porting to custom platform, as the reference implementation tears down the REST context created in fdo_con_setup() Parameters None Return Value 0 for success -1 for failure","title":"fdo_con_teardown()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_dns_lookup","text":"int32_t fdo_con_dns_lookup(const char *url, fdo_ip_address_t **ip_list, uint32_t *ip_list_size) Description This function performs a DNS lookup for the specified host identified by the url and return a list of IP addresses in the ip_list . Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to perform Domain Name resolution. Parameters url: NULL terminated string like \u201c192.168.0.1\u201d or \u201cexample@noname.com\u201d ip_list: Refer fdo_ip_address_t for the structure declaration. The usage of this structure is as follows: length: The value should be 4 for IPv4 and 16 for IPv6 addresses addr: specifies the IP address in network byte order ip_list_size: specifies the number of IP addresses in the ip_list. Return Value 0 for success -1 for failure","title":"fdo_con_dns_lookup()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_connect","text":"fdo_con_handle fdo_con_connect(fdo_ip_address_t *addr, uint16_t port, void **ssl) Description This function connects to the IP address specified in addr on the given port. If the ssl pointer is non-NULL, enable SSL on the opened socket. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to connect to the server. Parameters addr: server IP address. Please refer fdo_con_dns_lookup() port: server port to connect to ssl: NULL or valid pointer to receive the ssl context in case ssl is enabled Return Value Connection handle for success. Please refer fdo_con_handle . -1 for failure","title":"fdo_con_connect()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_disconnect","text":"int32_t fdo_con_disconnect(fdo_con_handle handle, void *ssl) Description This function terminates the connection associated with handle. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to disconnect from the server. Parameters handle: Valid connection handle. Please refer to fdo_con_connect() ssl: NULL or valid pointer in case, SSL connection was established. Please refer to fdo_con_connect() Return Value 0 for success -1 for failure","title":"fdo_con_disconnect()"},{"location":"client-sdk/client-sdk-porting-guide/#connection-data-management-functions","text":"","title":"Connection Data Management Functions"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_recv_msg_header","text":"int32_t fdo_con_recv_msg_header(fdo_con_handle handle, uint32_t *protocol_version, uint32_t *message_type, uint32_t *msglen, void *ssl) Description This function receives the message header on the specified connection handle and returns protocol_version , message_type and msglen . It will block until a message is available. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux* libraries to receive data from the server. Parameters handle: Connection handle. Please refer to fdo_con_connect() protocol_version: Incoming protocol version. Client SDK supports 113 message_type: set to FDO_TYPE_ERROR in case of error. Please refer FDO_TYPE_ERROR msglen: Length of incoming message body ssl: valid SSL context in case SSL is enabled. Please refer s do_con_connect() Return Value 0 for success -1 for failure","title":"fdo_con_recv_msg_header()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_recv_msg_body","text":"int32_t fdo_con_recv_msg_body(fdo_con_handle handle, uint8_t *buf, size_t length, void *ssl) Description This function receives the message body on the connection specified by handle in the provided memory pointed to by buf of size length . The message received corresponds to the message header received in the immediate preceding call to fdo_con_recv_msg_header() . This function blocks unless the specified length of data is received. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux* libraries to receive data from the server. Parameters handle: Connection handle. Please refer to fdo_con_connect() buf: pointer to the empty buffer for receiving the message length: size of buf and equal to returned from fdo_con_recv_msg_header(). ssl: valid SSL context in case SSL is enabled. Please refer to fdo_con_connect() Return Value Number of bytes for success -1 for failure","title":"fdo_con_recv_msg_body()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_con_send_message","text":"int32_t fdo_con_send_message(fdo_con_handle handle, uint32_t protocol_version, uint32_t message_type, const uint8_t *buf, size_t length, void *ssl) Description This function sends the data pointed by buf of size length over the connection specified by handle with protocol_version and message_type as metadata. Note This function may require a minimal change in implementation for porting to custom platform, as the reference implementation relies on Linux libraries to send data to the server. Parameters handle: Connection handle. Please refer to fdo_con_connect() protocol_version: Client SDK supports 113 message_type: Client SDK state machine specific. To be used as is buf: pointer to the buffer containing the message to be sent length: size of buf ssl: valid SSL context in case SSL is enabled. Please refer to fdo_con_connect() Return Value 0 for success -1 for failure","title":"fdo_con_send_message()"},{"location":"client-sdk/client-sdk-porting-guide/#network-generic-functions","text":"","title":"Network Generic Functions"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_net_to_host_long","text":"uint32_t fdo_net_to_host_long(uint32_t value) Description This function converts the value from network byte order to host byte order. Note This function may require a change in implementation for porting to custom platform, as the reference implementation to perform the functionality. Parameters value: unsigned integer of size 4 bytes in network byte order Return Value Unsigned integer of size 4 bytes converted to host byte order","title":"fdo_net_to_host_long()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_host_to_net_long","text":"uint32_t fdo_host_to_net_long(uint32_t value) Description This function converts the value from host byte order to network byte order. Note This function may require a change in implementation for porting to custom platform, as the reference implementation to perform the functionality. Parameters value: unsigned integer of size 4 bytes in host byte order Return Value Unsigned integer of size 4 bytes converted to network byte order","title":"fdo_host_to_net_long()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_printable_to_net","text":"int32_t fdo_printable_to_net(const char *src, void *addr) Description This function converts the IP address in ASCII string pointed to by src to network byte order and stores the result in addr . Note This function may require a change in implementation for porting to custom platform, as the reference implementation to perform the functionality. Parameters src: points to a character string containing an IPv4 network address in dotted-decimal format addr: output buffer to receive IPV4 network address in network byte order Return Value 1 for success -1 for failure 0 if input format is invalid","title":"fdo_printable_to_net()"},{"location":"client-sdk/client-sdk-porting-guide/#legacy-functions","text":"","title":"Legacy Functions"},{"location":"client-sdk/client-sdk-porting-guide/#get_device_model","text":"const char *get_device_model(void) Description This function either statically or dynamically generates a device model string. Note This function may require a change in implementation for porting to custom platform, as the reference implementation returns a hard-coded string. Parameters None Return Value NULL terminated ASCII string","title":"get_device_model()"},{"location":"client-sdk/client-sdk-porting-guide/#get_device_serial_number","text":"const char *get_device_serial_number(void) Description This function either statically or dynamically generates a device serial number string. Note This function may require a change in implementation for porting to custom platform, as the reference implementation returns a hard-coded string. Parameters None Return Value NULL terminated ASCII string","title":"get_device_serial_number()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_random","text":"int fdo_random(void) Description This function generates a random number Note This function may require a change in implementation for porting to custom platform, as the reference implementation uses Linux libraries to perform the functionality. Parameters None Return Value A random number","title":"fdo_random()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sleep","text":"void fdo_sleep(int sec) Description This function introduces the delay for sec number of seconds Note This function may require a change in implementation for porting to custom platform, as the reference implementation uses Linux libraries to perform the functionality.","title":"fdo_sleep()"},{"location":"client-sdk/client-sdk-porting-guide/#storage-subsystem-api","text":"Storage is a platform offering which enables Client SDK to store the credentials, state of the Client device on the storage medium. The required functionality by the Client SDK is abstracted via a set of APIs declared in file \"storage/include/storage_al.h\". Note This section of the document specifies the internal APIs to abstract Storage implementation from Client SDK and are subject to change.","title":"Storage Subsystem API"},{"location":"client-sdk/client-sdk-porting-guide/#constants_2","text":"","title":"Constants"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_sdk_blob_flags","text":"This enum defines the supported storage hierarchy by the API typedef enum { FDO_SDK_SECURE_DATA = 1, FDO_SDK_NORMAL_DATA = 2, FDO_SDK_OTP_DATA = 4, FDO_SDK_RAW_DATA = 8 } fdo_sdk_blob_flags; Enum Description FDO_SDK_SECURE_DATA This flag indicates to the storage API that the data is Authenticated Encrypted. As an example, the algorithm used could be AES-GCM or AES + HMAC to support this mode FDO_SDK_NORMAL_DATA This flag indicates to the storage API that the data contains Authentication information. As an example, the data is stored along with its HMAC FDO_SDK_OTP_DATA This flag indicates to the storage API that the data resides in One Time Programmable memory, so, essentially, only 1 write is possible. FDO_SDK_RAW_DATA This flag indicates to the storage API that the data is plaintext","title":"fdo_sdk_blob_flags"},{"location":"client-sdk/client-sdk-porting-guide/#data-types_1","text":"There are no specific data types for Storage APIs","title":"Data Types"},{"location":"client-sdk/client-sdk-porting-guide/#blob-functions","text":"","title":"Blob Functions"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_blob_read","text":"int32_t fdo_blob_read(const char *blob_name, fdo_sdk_blob_flags flags, uint8_t *buffer, uint32_t length) Description This function reads the data into the buffer of size length from the blob identified by blob_name whose storage properties match with the flags . Before reading the data from blob into the buffer , it is recommended to use fdo_blob_size() to allocate the exact length of buffer . Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure storage requirements for your device, refer to the Client SDK Security Implications document. Parameters blob_name: NULL terminated string identifying the existing blob flags: Please refer fdo_sdk_blob_flags buffer: empty buffer to read the blob data length: size of buffer Return Value Number of bytes read for success -1 for failure","title":"fdo_blob_read()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_blob_write","text":"int32_t fdo_blob_write(const char *blob_name, fdo_sdk_blob_flags flags, const uint8_t *buffer, uint32_t length) Description This function writes the data from buffer of size length to the blob identified by blob_name whose storage properties are identified with the flags . This function must create the blob if it doesn\u2019t exist, otherwise, overwrite the blob. Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure storage requirements for your device, refer to the Client SDK Security Implications document. Parameters blob_name: NULL terminated string identifying the blob to be created flags: Please refer fdo_sdk_blob_flags buffer: data to be stored in the blob length: size of the data to be stored into the blob Return Value Number of bytes written for success -1 for failure","title":"fdo_blob_write()"},{"location":"client-sdk/client-sdk-porting-guide/#fdo_blob_size","text":"size_t fdo_blob_size(const char *blob_name, fdo_sdk_blob_flags flags) Description This function returns the size of blob identified by blob_name whose storage properties match with the flags . This should be used before fdo_blob_read() Note This function may require a change in implementation for porting to a custom platform. For guidance in assessing the secure storage requirements for your device, refer to the Client SDK Security Implications document. Parameters blob_name: NULL terminated string identifying the existing blob flags: Please refer fdo_sdk_blob_flags Return Value Blob size for success file size on success 0 if file does not exist or in case of failure","title":"fdo_blob_size()"},{"location":"client-sdk/client-sdk-reference-guide/","text":"Introduction \u00b6 The FIDO Device Onboard Client SDK is a portable implementation of the FIDO Device Onboard (FDO) protocol state machines, cryptographic operations, and associated components. While the Client SDK was developed and tested on the Linux* OS, the core components of the SDK are isolated from OS-specific components via an abstraction layer. Well-known open-source implementations of cryptographic libraries are used for cryptographic operations. In addition, the Client SDK will be ported to the following Arm* platforms in future releases: Nucleo development board (NUCLEO-F429ZI) running STM32F429ZI ARM Cortex -M4 MCU over Mbed* OS. NUCLEO-F767ZI development board running STM32F767ZI Arm Cortex -M7 MCU over Mbed* OS. WaRP7 development board running i.MX 7 series Arm Cortex-A7 MPU over Mbed Linux. The Client SDK is a reference implementation that can be used to onboard a device and then give control to the device application or IOT Platform Service. \u201cOnboarding\u201d means the process by which a device establishes its first trusted connection with an IOT Platform Service. Linux provides an easy-to-use development environment for SDK development, debug, and validation. When the SDK is ported to a particular environment, the abstraction layer will be ported to the target environment and real-time operating system (RTOS) (or bare metal). If the target environment supports hardware-accelerated cryptography, the cryptography interfaces will also be ported. If the target environment does not support cryptographic acceleration, the software cryptography libraries used by the SDK will need to be ported. The core SDK can be recompiled in the target environment with no change. Note The hardware abstraction layer (HAL) implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment. Terminology \u00b6 Refer to the FIDO Device Onboard Reference page . Reference Documents \u00b6 Refer to the FIDO Device Onboard Reference page . Client SDK Overview \u00b6 Like any SDK, the Client SDK is expected to be embedded within a custom implementation that provides overall device functionality while using the SDK to perform FDO-based device onboarding. The SDK will be statically linked to an application that invokes SDK APIs to trigger onboarding functionality. This implementation is referred to as the \u2018Application\u2019 in this document. Figure 1. FDO Client Block Diagram Note FDO is an acronym for FIDO Device Onboard. Before initiating the FIDO Device Onboard functionality, the Application must first initialize the SDK. After initializing the SDK, the Application can initiate the onboarding by calling the fdo_sdk_run() API. The SDK maintains persistent data such as configuration and state information that are used to track the onboarding state and store credentials, among others. This information is stored in the SDK Configuration file that persists across reboots. Threading Model \u00b6 The FDO Client SDK is single-threaded and the APIs are non-reentrant and blocking. SDK code executes in the context of the calling application thread and will make OS calls via the abstraction layer for storage and networking services within the context of this thread. OS services such as storage and network are assumed to be blocking. During the execution of the onboarding protocol, the SDK receives data from the Owner Server that must be passed back to application modules (Pre-Service & Owner ServiceInfo). This is achieved via module-specific callback functions that are registered during the SDK initialization. These callback functions are also called within the context of the application thread that entered the SDK via one of the SDK\u2019s APIs ( fdo_sdk_run ). The application must not invoke an SDK API from within the callback \u2013 SDK flows have been designed such that this is not required. In addition to module specific callbacks, the SDK requires an additional callback that is used to inform the Application of events occurring during long-running activities, such as network connection retries, as well as errors, such as network connection drop. Networking \u00b6 It is assumed that the machine on which the SDK runs has access to the network. The SDK uses a standard POSIX sockets interface to connect to external back-end Rendezvous and Owner Servers. The SDK uses the OpenSSL* toolkit for SSL support. The SDK will initiate connections to the following external ports, which must not be blocked by a firewall: 8039: The SDK connects to the FDO Manufacturer Server on this port. 8040: The SDK connects to the FDO Rendezvous Server on this port. 8042: The SDK connects to the FDO Owner Server on this port. For details on the Manufacturer Server, Rendezvous Server, and Owner Server refer to the Reference Documents. Device-Specific Modules \u00b6 FDO is a generic mechanism of establishing trust between a device and the final owner\u2019s cloud-based IOT Platform Service (known as the Owner Service). Once this trust is established, the Owner Service must perform the following actions: Setup the device for final operation. This requires configuration of device specific operational parameters. This is determined by the device being onboarded, for example, it is device specific. Full integration into the organization\u2019s IOT Platform Service. This is specific to the IOT Platform Service being used. Since FDO cannot define these steps for all devices and IOT Platforms, it provides a flexible method to allow these operations to be carried out in a secure manner using Modules. Modules are defined by the device manufacturer (ODM) and are pieces of code that have a specific name and perform a specific function. Firmware update, key provisioning, and Wi-Fi* network setup are some examples of common functionality that could be provided by modules. A module must be able to report information [called the Device ServiceInfo ], to IOT Platform, and/or accept configuration information [called the Owner ServiceInfo ], from the Owner Service. A module must also be able to publish details of what information it will report as Device ServiceInfo and/or what information it will accept as Owner ServiceInfo. This is done in the form of key-value pairs. The key identifies a parameter and the value provides the value of the parameter. A module will publish its interface in the form of Device and Owner ServiceInfo Keys (ServiceInfoKey) with associated valid values (ServiceInfoVal). The Owner Service is expected to be aware of all devices it will onboard and associated Device and Owner ServiceInfo interfaces. Note In this release, a module can only be integrated for processing Owner ServiceInfo. Support for integrating Device ServiceInfo modules into the Client SDK will be added in future releases. Note The expectation is that over time, much like reusable libraries, modules providing specific functionality such as firmware updates or key provisioning will become standardized in terms of their capabilities and interfaces. Device manufactures will simply port the modules and include these libraries in their device implementation. A similar development is expected to occur on the Owner Server-side where standard libraries will be developed to interact with the device module and included in the Owner Server implementation. When a device is onboarded, a secure channel is established between the device and the Owner Server after the device has authenticated the Owner Server and vice-versa (during the TO2 protocol). At this point, the Owner Server can query information from the device (Device ServiceInfo) and send down configuration information to the device (Owner ServiceInfo). The secure channel uses encryption and integrity protection to secure Device ServiceInfo/Owner ServiceInfo data in transit from/to the device. The Device ServiceInfo must always send 'devmod' module as the very first module, containing a list of supported modules along with basic capabilities expected of the module. The following section details the interactions between the Application, Client SDK and Device-specific Modules. Integrated Operational Flows \u00b6 This SDK release requires all software components to be linked together into a single binary image and execute at the same privilege level. While some systems might include overlays and Trusted Execution Environments, these are not considered for this version. Figure 2. Integrated Image and Execution Flow The integrated image and execution flows from system boot are shown above and each step is described below: On reset, the Board Support Package (BSP) and RTOS initialize the hardware and pass the control to the Application. On Linux* systems, this is the normal OS boot flow and is complete by the time the Application executes. The Application initializes all FDO modules if required. The Application also initializes the SDK by calling the fdo_sdk_init() API and registers each module with the SDK by passing the module\u2019s name and callback address to the SDK (in the fdo_sdk_service_info_module structure). The Application checks if FDO onboarding has been completed by calling the fdo_sdk_get_status() API. If the status FDO_SDK_STATE_IDLE is returned, onboarding has been completed and the Application goes to step 6. If not, the Application goes to step 4. The Application initiates FDO onboarding by calling the fdo_sdk_run() API. This call returns either a successful completion of onboarding or an error. If an error occurs, the Application will reset the device and retry the sequence, with some delay. On successful completion of onboarding, the Application goes to step 6. During the onboarding process, the SDK will call registered modules during the ServiceInfo stage of the protocol. This is done by calling the registered module callback. Details of this interaction are provided in the Figure 3. The onboarding process will succeed only if all module interactions at this stage are successful. The Application has successfully completed onboarding and continues the normal operation of the device. The Application continues operating until the system is powered off or reset. On System restart, the preceding steps are re-executed. FDO Module Flows \u00b6 As mentioned in Device Specific Modules section , three types of information exchange occur between each module and the Owner Service: Device ServiceInfo Owner ServiceInfo Each of these is described as follows: Figure 3. ServiceInfo Exchanges between Device and Owner Server Module Initialization \u00b6 For each registered module, the SDK initializes the module by calling its callback with the FDO_SI_START type. The module is expected to prepare to receive PSI, Device ServiceInfo, and Owner ServiceInfo calls after initialization. If an error occurs after a module has been initialized, during the remainder of TO2 protocol execution and the Application is restarted, the SDK will again call this API to initialize each registered module. The module must be prepared for multiple such calls due to the SDK\u2019s retry-based approach to error recovery. Device ServiceInfo \u00b6 This is the information that make the Owner aware of the supported Owner ServiceInfo modules along with other information that aids in proper configuration of the Device. The module needs to determine in advance how many Device ServiceInfo key-value pairs it needs to send to the Owner Service. The Device initially sends the 'devmod' module in the first round. Other module is sent to the Owner in subsequent rounds. As mentioned previously, only one Device ServiceInfo module is supported currently, i.e, devmod module, which is configured statically in add_module_devmod() . All but one of the parameters are configured in the same method, except Device ServiceInfo Key devmod:modules that is partially configured here, and in fdo_serviceinfo_modules_list_write() . The total number of supported Owner ServiceInfo modules and their names must be updated in the above mentioned methods. Support for handling multiple Device ServiceInfo modules will be added in future releases. Note that Device ServiceInfo is one way for now \u2013 from device to Owner Server. The Owner Server cannot respond to any Device ServiceInfo message during this phase. Owner ServiceInfo \u00b6 Owner ServiceInfo follows Device ServiceInfo. Unlike Device ServiceInfo, neither the SDK nor the module can determine in advance how many Owner ServiceInfo key-values they are going to receive. On receiving an Owner ServiceInfo, the SDK locates the module and invokes its callback with the FDO_SI_SET_OSI type. The Owner is supposed to send module activation message, that is it sends an active key with value true for a particular module, prior to sending the Owner ServiceInfo for that module. When the SDK receives the same, it activates that particular module and passes on the subsequent ServiceInfo key-values to that module. If the SDK receives ServiceInfo for a module that is not currently active, it returns without throwing any error, without invoking the callback method. If the SDK receives ServiceInfo for a module that is not supported, it keeps on adding the received module name 'modname' to an internal list, and responds with [modname:active, false] for each unsupported module names encountered so far, when the Owner sends TO2.OwnerServiceInfo.isMore as false. Optionally, the Owner Server could send a deactivation message to a module, that is it sends active key with value false for a particular module if it is not planning to use the module. Received key-values are passed to the module in the module_message and fdor callback parameter fields. The internal buffer of fdor contains the entire message as received in TO2.OwnerServiceInfo (Type 69) with the current position set to the received Owner ServiceInfo value (ServiceInfoVal), while the Owner ServiceInfo key (ServiceInfoKey) is provided in module_message. The module must read the value from fdor_t , process it as per the key, and advance the fdor_t internal buffer to the next valid CBOR entry (currently being done internally in few methods). The module must treat the received fdor_t as a read-only structure, and must never modify it, excpet advancing to the next CBOR entry. It is assumed that the module knows how to interpret the value for a particular key based on the key. The module is expected to process the key-value pair and return a result indicating if the operation was successful or failed. The module may return FDO_SI_CONTENT_ERROR or FDO_SI_INTERNAL_ERROR to differentiate between invalid value contents or a module run-time error. This information is reported to the Owner Server. The module must return FDO_SI_SUCCESS on successful completion. Note that Owner ServiceInfo is one way \u2013 from Owner Server to the device. Apart from indicating failure or returning a list of unsupported module names, the device cannot respond to an Owner ServiceInfo message, for now. Module Completion \u00b6 When all ServiceInfo rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the FDO_SI_END type. All other callback parameters are NULL . Modules can commit configuration information at this point if not already done so. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point. Module Errors \u00b6 If an error occurs during the ServiceInfo phase, the TO2 protocol is considered to have failed and will be aborted. The Application will need to retry onboarding later. A failure could occur for multiple reasons including failure of device/server interaction, failure of signature or hash verification, malformed messages and if a module returns a failure while processing a PSI, Device ServiceInfo, or Owner ServiceInfo command/request. On failure, all modules must clean up internal state and discard any configuration information they might have got from the Owner Server. Conversely, the Owner Server will also discard all data it might have received from modules. When all ServiceInfo rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the FDO_SI_FAILURE type. All other callback parameters are NULL . Modules must discard all information received via Owner ServiceInfo commands until this point. If operations have been performed, or data already committed, they should be undone to return the system to its initial state. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point. Run the Client SDK \u00b6 The Client SDK includes a binary package, intended to get you started quickly and a source package. For details on downloading the packages, refer to the Get Started Guide. Prerequisites \u00b6 The requirements for the computer that you will run Client SDK on are as follows: Table 1. Prerequisites Software \u00b7 Linux* Ubuntu* 20.04 using OpenSSL* 1.1.1k . Download FDO PRI Components-Samples 0.5-rel (for running test servers) from https://github.com/secure-device-onboard/pri-fidoiot. Safestring library Safestring library v1.0.0 \u00b7 Download safestringlib from https://github.com/intel/safestringlib \u00b7 cd safestringlib \u00b7 mkdir obj \u00b7 make \u00b7 The library file libsafestring.a will be created after make. TinyCBOR library TinyCBOR library v0.5.3 \u00b7 Download TinyCBOR from https://github.com/intel/tinycbor \u00b7 cd tinycbor \u00b7 make Get the Device Private Key (ECDSA based) \u00b6 The SDK requires a device Private Key as input for device attestation process (to prove itself to Rendezvous or Owner Server during TO1 or TO2 protocol). The key could be based on ECDSA (on curve P-256/P-384) based on the device attestation method being used on the field. This key must be stored in a specific file and is read by the SDK on startup. The Private key can be generated by running bash utils/keys_gen.sh . at client-sdk-fidoiot\\ . For ECDSA (P-256) based device-attestation method: In case of ECDSA, place the ECDSA P-256 private Key with the name ecdsa256privkey.dat in the following location: data/ecdsa256privkey.dat For ECDSA (P-384) based device-attestation method: For ECDSA384, place the ECDSA P-384 private Key with the name ecdsa384privkey.dat in the following location: data/ecdsa384privkey.data Run the FDO Client SDK Onboarding Demo \u00b6 Refer to Client SDK README for detailed steps on setting up FDO Client SDK and FDO PRI Manufacturer, Rendezvous and Owner and running the demo. Custom Pluggable Modules \u00b6 As part of the onboard protocol, the Client SDK supports custom pluggable modules. OEMs can develop their desired functionality by following the module protocol. This module functionality will be called during the onboard protocol. A sample device module, fdo_sys has been developed as per specification , and is available as a reference ServiceInfo module implementation. fdo_sys device module is intended to collect the data (typically files and scripts) sent from the FDO PRI Owner to the FDO Client SDK, process, and execute the data in some meaningful way. It is integrated into the source at client-sdk-fidoiot/app/main.c (added as a module) and client-sdk-fidoiot/lib/fdotypes.c (used to write 'devmod:modules'), and is compiled by default as per cmake configurations. Known Issues and Limitations \u00b6 The following are the known issues: \u2022 The HAL implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment. \u2022 \u2018fdo_sys\u2019 module source within 'device_modules' folder is an example code demonstrating FDO device module implementation for reference purpose only. The executable script must only contain alpha-numeric characters, hyphen (-) and underscore (_) in their names, with extensions .py and .sh . This code is not written following secure production level coding and checks. This sample code must not be used as it is. The following are the known limitations: \u2022 The ARM platforms, namely ARM Cortex M4, M7, and A7 devices, as well as mbedTLS and SE crypto operations, are not supported in this release.","title":"Client SDK Introduction"},{"location":"client-sdk/client-sdk-reference-guide/#introduction","text":"The FIDO Device Onboard Client SDK is a portable implementation of the FIDO Device Onboard (FDO) protocol state machines, cryptographic operations, and associated components. While the Client SDK was developed and tested on the Linux* OS, the core components of the SDK are isolated from OS-specific components via an abstraction layer. Well-known open-source implementations of cryptographic libraries are used for cryptographic operations. In addition, the Client SDK will be ported to the following Arm* platforms in future releases: Nucleo development board (NUCLEO-F429ZI) running STM32F429ZI ARM Cortex -M4 MCU over Mbed* OS. NUCLEO-F767ZI development board running STM32F767ZI Arm Cortex -M7 MCU over Mbed* OS. WaRP7 development board running i.MX 7 series Arm Cortex-A7 MPU over Mbed Linux. The Client SDK is a reference implementation that can be used to onboard a device and then give control to the device application or IOT Platform Service. \u201cOnboarding\u201d means the process by which a device establishes its first trusted connection with an IOT Platform Service. Linux provides an easy-to-use development environment for SDK development, debug, and validation. When the SDK is ported to a particular environment, the abstraction layer will be ported to the target environment and real-time operating system (RTOS) (or bare metal). If the target environment supports hardware-accelerated cryptography, the cryptography interfaces will also be ported. If the target environment does not support cryptographic acceleration, the software cryptography libraries used by the SDK will need to be ported. The core SDK can be recompiled in the target environment with no change. Note The hardware abstraction layer (HAL) implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment.","title":"Introduction"},{"location":"client-sdk/client-sdk-reference-guide/#terminology","text":"Refer to the FIDO Device Onboard Reference page .","title":"Terminology"},{"location":"client-sdk/client-sdk-reference-guide/#reference-documents","text":"Refer to the FIDO Device Onboard Reference page .","title":"Reference Documents"},{"location":"client-sdk/client-sdk-reference-guide/#client-sdk-overview","text":"Like any SDK, the Client SDK is expected to be embedded within a custom implementation that provides overall device functionality while using the SDK to perform FDO-based device onboarding. The SDK will be statically linked to an application that invokes SDK APIs to trigger onboarding functionality. This implementation is referred to as the \u2018Application\u2019 in this document. Figure 1. FDO Client Block Diagram Note FDO is an acronym for FIDO Device Onboard. Before initiating the FIDO Device Onboard functionality, the Application must first initialize the SDK. After initializing the SDK, the Application can initiate the onboarding by calling the fdo_sdk_run() API. The SDK maintains persistent data such as configuration and state information that are used to track the onboarding state and store credentials, among others. This information is stored in the SDK Configuration file that persists across reboots.","title":"Client SDK Overview"},{"location":"client-sdk/client-sdk-reference-guide/#threading-model","text":"The FDO Client SDK is single-threaded and the APIs are non-reentrant and blocking. SDK code executes in the context of the calling application thread and will make OS calls via the abstraction layer for storage and networking services within the context of this thread. OS services such as storage and network are assumed to be blocking. During the execution of the onboarding protocol, the SDK receives data from the Owner Server that must be passed back to application modules (Pre-Service & Owner ServiceInfo). This is achieved via module-specific callback functions that are registered during the SDK initialization. These callback functions are also called within the context of the application thread that entered the SDK via one of the SDK\u2019s APIs ( fdo_sdk_run ). The application must not invoke an SDK API from within the callback \u2013 SDK flows have been designed such that this is not required. In addition to module specific callbacks, the SDK requires an additional callback that is used to inform the Application of events occurring during long-running activities, such as network connection retries, as well as errors, such as network connection drop.","title":"Threading Model"},{"location":"client-sdk/client-sdk-reference-guide/#networking","text":"It is assumed that the machine on which the SDK runs has access to the network. The SDK uses a standard POSIX sockets interface to connect to external back-end Rendezvous and Owner Servers. The SDK uses the OpenSSL* toolkit for SSL support. The SDK will initiate connections to the following external ports, which must not be blocked by a firewall: 8039: The SDK connects to the FDO Manufacturer Server on this port. 8040: The SDK connects to the FDO Rendezvous Server on this port. 8042: The SDK connects to the FDO Owner Server on this port. For details on the Manufacturer Server, Rendezvous Server, and Owner Server refer to the Reference Documents.","title":"Networking"},{"location":"client-sdk/client-sdk-reference-guide/#device-specific-modules","text":"FDO is a generic mechanism of establishing trust between a device and the final owner\u2019s cloud-based IOT Platform Service (known as the Owner Service). Once this trust is established, the Owner Service must perform the following actions: Setup the device for final operation. This requires configuration of device specific operational parameters. This is determined by the device being onboarded, for example, it is device specific. Full integration into the organization\u2019s IOT Platform Service. This is specific to the IOT Platform Service being used. Since FDO cannot define these steps for all devices and IOT Platforms, it provides a flexible method to allow these operations to be carried out in a secure manner using Modules. Modules are defined by the device manufacturer (ODM) and are pieces of code that have a specific name and perform a specific function. Firmware update, key provisioning, and Wi-Fi* network setup are some examples of common functionality that could be provided by modules. A module must be able to report information [called the Device ServiceInfo ], to IOT Platform, and/or accept configuration information [called the Owner ServiceInfo ], from the Owner Service. A module must also be able to publish details of what information it will report as Device ServiceInfo and/or what information it will accept as Owner ServiceInfo. This is done in the form of key-value pairs. The key identifies a parameter and the value provides the value of the parameter. A module will publish its interface in the form of Device and Owner ServiceInfo Keys (ServiceInfoKey) with associated valid values (ServiceInfoVal). The Owner Service is expected to be aware of all devices it will onboard and associated Device and Owner ServiceInfo interfaces. Note In this release, a module can only be integrated for processing Owner ServiceInfo. Support for integrating Device ServiceInfo modules into the Client SDK will be added in future releases. Note The expectation is that over time, much like reusable libraries, modules providing specific functionality such as firmware updates or key provisioning will become standardized in terms of their capabilities and interfaces. Device manufactures will simply port the modules and include these libraries in their device implementation. A similar development is expected to occur on the Owner Server-side where standard libraries will be developed to interact with the device module and included in the Owner Server implementation. When a device is onboarded, a secure channel is established between the device and the Owner Server after the device has authenticated the Owner Server and vice-versa (during the TO2 protocol). At this point, the Owner Server can query information from the device (Device ServiceInfo) and send down configuration information to the device (Owner ServiceInfo). The secure channel uses encryption and integrity protection to secure Device ServiceInfo/Owner ServiceInfo data in transit from/to the device. The Device ServiceInfo must always send 'devmod' module as the very first module, containing a list of supported modules along with basic capabilities expected of the module. The following section details the interactions between the Application, Client SDK and Device-specific Modules.","title":"Device-Specific Modules"},{"location":"client-sdk/client-sdk-reference-guide/#integrated-operational-flows","text":"This SDK release requires all software components to be linked together into a single binary image and execute at the same privilege level. While some systems might include overlays and Trusted Execution Environments, these are not considered for this version. Figure 2. Integrated Image and Execution Flow The integrated image and execution flows from system boot are shown above and each step is described below: On reset, the Board Support Package (BSP) and RTOS initialize the hardware and pass the control to the Application. On Linux* systems, this is the normal OS boot flow and is complete by the time the Application executes. The Application initializes all FDO modules if required. The Application also initializes the SDK by calling the fdo_sdk_init() API and registers each module with the SDK by passing the module\u2019s name and callback address to the SDK (in the fdo_sdk_service_info_module structure). The Application checks if FDO onboarding has been completed by calling the fdo_sdk_get_status() API. If the status FDO_SDK_STATE_IDLE is returned, onboarding has been completed and the Application goes to step 6. If not, the Application goes to step 4. The Application initiates FDO onboarding by calling the fdo_sdk_run() API. This call returns either a successful completion of onboarding or an error. If an error occurs, the Application will reset the device and retry the sequence, with some delay. On successful completion of onboarding, the Application goes to step 6. During the onboarding process, the SDK will call registered modules during the ServiceInfo stage of the protocol. This is done by calling the registered module callback. Details of this interaction are provided in the Figure 3. The onboarding process will succeed only if all module interactions at this stage are successful. The Application has successfully completed onboarding and continues the normal operation of the device. The Application continues operating until the system is powered off or reset. On System restart, the preceding steps are re-executed.","title":"Integrated Operational Flows"},{"location":"client-sdk/client-sdk-reference-guide/#fdo-module-flows","text":"As mentioned in Device Specific Modules section , three types of information exchange occur between each module and the Owner Service: Device ServiceInfo Owner ServiceInfo Each of these is described as follows: Figure 3. ServiceInfo Exchanges between Device and Owner Server","title":"FDO Module Flows"},{"location":"client-sdk/client-sdk-reference-guide/#module-initialization","text":"For each registered module, the SDK initializes the module by calling its callback with the FDO_SI_START type. The module is expected to prepare to receive PSI, Device ServiceInfo, and Owner ServiceInfo calls after initialization. If an error occurs after a module has been initialized, during the remainder of TO2 protocol execution and the Application is restarted, the SDK will again call this API to initialize each registered module. The module must be prepared for multiple such calls due to the SDK\u2019s retry-based approach to error recovery.","title":"Module Initialization"},{"location":"client-sdk/client-sdk-reference-guide/#device-serviceinfo","text":"This is the information that make the Owner aware of the supported Owner ServiceInfo modules along with other information that aids in proper configuration of the Device. The module needs to determine in advance how many Device ServiceInfo key-value pairs it needs to send to the Owner Service. The Device initially sends the 'devmod' module in the first round. Other module is sent to the Owner in subsequent rounds. As mentioned previously, only one Device ServiceInfo module is supported currently, i.e, devmod module, which is configured statically in add_module_devmod() . All but one of the parameters are configured in the same method, except Device ServiceInfo Key devmod:modules that is partially configured here, and in fdo_serviceinfo_modules_list_write() . The total number of supported Owner ServiceInfo modules and their names must be updated in the above mentioned methods. Support for handling multiple Device ServiceInfo modules will be added in future releases. Note that Device ServiceInfo is one way for now \u2013 from device to Owner Server. The Owner Server cannot respond to any Device ServiceInfo message during this phase.","title":"Device ServiceInfo"},{"location":"client-sdk/client-sdk-reference-guide/#owner-serviceinfo","text":"Owner ServiceInfo follows Device ServiceInfo. Unlike Device ServiceInfo, neither the SDK nor the module can determine in advance how many Owner ServiceInfo key-values they are going to receive. On receiving an Owner ServiceInfo, the SDK locates the module and invokes its callback with the FDO_SI_SET_OSI type. The Owner is supposed to send module activation message, that is it sends an active key with value true for a particular module, prior to sending the Owner ServiceInfo for that module. When the SDK receives the same, it activates that particular module and passes on the subsequent ServiceInfo key-values to that module. If the SDK receives ServiceInfo for a module that is not currently active, it returns without throwing any error, without invoking the callback method. If the SDK receives ServiceInfo for a module that is not supported, it keeps on adding the received module name 'modname' to an internal list, and responds with [modname:active, false] for each unsupported module names encountered so far, when the Owner sends TO2.OwnerServiceInfo.isMore as false. Optionally, the Owner Server could send a deactivation message to a module, that is it sends active key with value false for a particular module if it is not planning to use the module. Received key-values are passed to the module in the module_message and fdor callback parameter fields. The internal buffer of fdor contains the entire message as received in TO2.OwnerServiceInfo (Type 69) with the current position set to the received Owner ServiceInfo value (ServiceInfoVal), while the Owner ServiceInfo key (ServiceInfoKey) is provided in module_message. The module must read the value from fdor_t , process it as per the key, and advance the fdor_t internal buffer to the next valid CBOR entry (currently being done internally in few methods). The module must treat the received fdor_t as a read-only structure, and must never modify it, excpet advancing to the next CBOR entry. It is assumed that the module knows how to interpret the value for a particular key based on the key. The module is expected to process the key-value pair and return a result indicating if the operation was successful or failed. The module may return FDO_SI_CONTENT_ERROR or FDO_SI_INTERNAL_ERROR to differentiate between invalid value contents or a module run-time error. This information is reported to the Owner Server. The module must return FDO_SI_SUCCESS on successful completion. Note that Owner ServiceInfo is one way \u2013 from Owner Server to the device. Apart from indicating failure or returning a list of unsupported module names, the device cannot respond to an Owner ServiceInfo message, for now.","title":"Owner ServiceInfo"},{"location":"client-sdk/client-sdk-reference-guide/#module-completion","text":"When all ServiceInfo rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the FDO_SI_END type. All other callback parameters are NULL . Modules can commit configuration information at this point if not already done so. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point.","title":"Module Completion"},{"location":"client-sdk/client-sdk-reference-guide/#module-errors","text":"If an error occurs during the ServiceInfo phase, the TO2 protocol is considered to have failed and will be aborted. The Application will need to retry onboarding later. A failure could occur for multiple reasons including failure of device/server interaction, failure of signature or hash verification, malformed messages and if a module returns a failure while processing a PSI, Device ServiceInfo, or Owner ServiceInfo command/request. On failure, all modules must clean up internal state and discard any configuration information they might have got from the Owner Server. Conversely, the Owner Server will also discard all data it might have received from modules. When all ServiceInfo rounds of all modules have completed successfully, the SDK calls each module\u2019s callback with the FDO_SI_FAILURE type. All other callback parameters are NULL . Modules must discard all information received via Owner ServiceInfo commands until this point. If operations have been performed, or data already committed, they should be undone to return the system to its initial state. The SDK will not call into the module after this. The SDK will ignore the return value of this callback since no further failure is expected at this point.","title":"Module Errors"},{"location":"client-sdk/client-sdk-reference-guide/#run-the-client-sdk","text":"The Client SDK includes a binary package, intended to get you started quickly and a source package. For details on downloading the packages, refer to the Get Started Guide.","title":"Run the Client SDK"},{"location":"client-sdk/client-sdk-reference-guide/#prerequisites","text":"The requirements for the computer that you will run Client SDK on are as follows: Table 1. Prerequisites Software \u00b7 Linux* Ubuntu* 20.04 using OpenSSL* 1.1.1k . Download FDO PRI Components-Samples 0.5-rel (for running test servers) from https://github.com/secure-device-onboard/pri-fidoiot. Safestring library Safestring library v1.0.0 \u00b7 Download safestringlib from https://github.com/intel/safestringlib \u00b7 cd safestringlib \u00b7 mkdir obj \u00b7 make \u00b7 The library file libsafestring.a will be created after make. TinyCBOR library TinyCBOR library v0.5.3 \u00b7 Download TinyCBOR from https://github.com/intel/tinycbor \u00b7 cd tinycbor \u00b7 make","title":"Prerequisites"},{"location":"client-sdk/client-sdk-reference-guide/#get-the-device-private-key-ecdsa-based","text":"The SDK requires a device Private Key as input for device attestation process (to prove itself to Rendezvous or Owner Server during TO1 or TO2 protocol). The key could be based on ECDSA (on curve P-256/P-384) based on the device attestation method being used on the field. This key must be stored in a specific file and is read by the SDK on startup. The Private key can be generated by running bash utils/keys_gen.sh . at client-sdk-fidoiot\\ . For ECDSA (P-256) based device-attestation method: In case of ECDSA, place the ECDSA P-256 private Key with the name ecdsa256privkey.dat in the following location: data/ecdsa256privkey.dat For ECDSA (P-384) based device-attestation method: For ECDSA384, place the ECDSA P-384 private Key with the name ecdsa384privkey.dat in the following location: data/ecdsa384privkey.data","title":"Get the Device Private Key (ECDSA based)"},{"location":"client-sdk/client-sdk-reference-guide/#run-the-fdo-client-sdk-onboarding-demo","text":"Refer to Client SDK README for detailed steps on setting up FDO Client SDK and FDO PRI Manufacturer, Rendezvous and Owner and running the demo.","title":"Run the FDO Client SDK Onboarding Demo"},{"location":"client-sdk/client-sdk-reference-guide/#custom-pluggable-modules","text":"As part of the onboard protocol, the Client SDK supports custom pluggable modules. OEMs can develop their desired functionality by following the module protocol. This module functionality will be called during the onboard protocol. A sample device module, fdo_sys has been developed as per specification , and is available as a reference ServiceInfo module implementation. fdo_sys device module is intended to collect the data (typically files and scripts) sent from the FDO PRI Owner to the FDO Client SDK, process, and execute the data in some meaningful way. It is integrated into the source at client-sdk-fidoiot/app/main.c (added as a module) and client-sdk-fidoiot/lib/fdotypes.c (used to write 'devmod:modules'), and is compiled by default as per cmake configurations.","title":"Custom Pluggable Modules"},{"location":"client-sdk/client-sdk-reference-guide/#known-issues-and-limitations","text":"The following are the known issues: \u2022 The HAL implementation provided in this release is for reference only and not intended for production. It does not provide the level of security required by industry standards for a fully secure production environment. \u2022 \u2018fdo_sys\u2019 module source within 'device_modules' folder is an example code demonstrating FDO device module implementation for reference purpose only. The executable script must only contain alpha-numeric characters, hyphen (-) and underscore (_) in their names, with extensions .py and .sh . This code is not written following secure production level coding and checks. This sample code must not be used as it is. The following are the known limitations: \u2022 The ARM platforms, namely ARM Cortex M4, M7, and A7 devices, as well as mbedTLS and SE crypto operations, are not supported in this release.","title":"Known Issues and Limitations"},{"location":"implementation-references/device-mfg-info/","text":"Device-mfg-info \u00b6 The device-mfg-info (DeviceMfgInfo) is used to convey device specific information to the manufacturer tool via message 10 (DIAppStart) of the DI protocol from the device. An FDO application that runs on the device generates the DeviceMfgInfo value. Typically, the device serial number and device info are provided as input to this application. The DeviceMfgInfo must be present and cannot be empty (otherwise an error will result during the DI protocol). The DeviceMfgInfo format is a CBOR encoded array consisting of the following entries: First entry: (integer) Key type identifier Second entry: (string) Serial number Third entry: (string) Device Info Fourth entry: (bstr) CSR (ECC based device) or device cert chain (OnDie ECDSA based device) if the device is using an ECC keypair, a CSR. if the device is OnDie ECDSA then the device cert chain Fifth entry: (bstr) test signature (present only for OnDie ECDSA devices) where: Key type identifier = 1 | 13 | 14 1 = RSA256, 13 = ECC256, 14 = ECC384 Identifies the type of owner key the device is prepared to parse, not the type of the device's key. Serial number = device serial number The serial number should uniquely identify the device and ideally, should be present on the device itself (such as, the label). It is used to correlate the device with its associated ownership voucher by manufacturers and resellers when shipping devices. Device Info = device info Typically used to provided the device's model number. This data is not strictly required and can be empty if desired. CSR = certificate signing request. The CSR is optional and is only required for ECC devices. The format of the CSR should be base 64-encoded public key cryptography standards (PKCS#10) in privacy-enhanced mail (PEM) format. device cert chain = device cert chain The device cert chain for OnDie ECDSA based devices. test signature = test signature The signature resulting from signing of the 'Serial number' entry. This is used to validate the signing and verification mechanism during manufacturing.","title":"DeviceMfgInfo Specification"},{"location":"implementation-references/device-mfg-info/#device-mfg-info","text":"The device-mfg-info (DeviceMfgInfo) is used to convey device specific information to the manufacturer tool via message 10 (DIAppStart) of the DI protocol from the device. An FDO application that runs on the device generates the DeviceMfgInfo value. Typically, the device serial number and device info are provided as input to this application. The DeviceMfgInfo must be present and cannot be empty (otherwise an error will result during the DI protocol). The DeviceMfgInfo format is a CBOR encoded array consisting of the following entries: First entry: (integer) Key type identifier Second entry: (string) Serial number Third entry: (string) Device Info Fourth entry: (bstr) CSR (ECC based device) or device cert chain (OnDie ECDSA based device) if the device is using an ECC keypair, a CSR. if the device is OnDie ECDSA then the device cert chain Fifth entry: (bstr) test signature (present only for OnDie ECDSA devices) where: Key type identifier = 1 | 13 | 14 1 = RSA256, 13 = ECC256, 14 = ECC384 Identifies the type of owner key the device is prepared to parse, not the type of the device's key. Serial number = device serial number The serial number should uniquely identify the device and ideally, should be present on the device itself (such as, the label). It is used to correlate the device with its associated ownership voucher by manufacturers and resellers when shipping devices. Device Info = device info Typically used to provided the device's model number. This data is not strictly required and can be empty if desired. CSR = certificate signing request. The CSR is optional and is only required for ECC devices. The format of the CSR should be base 64-encoded public key cryptography standards (PKCS#10) in privacy-enhanced mail (PEM) format. device cert chain = device cert chain The device cert chain for OnDie ECDSA based devices. test signature = test signature The signature resulting from signing of the 'Serial number' entry. This is used to validate the signing and verification mechanism during manufacturing.","title":"Device-mfg-info"},{"location":"implementation-references/dms-integration-guide/","text":"Introduction \u00b6 FIDO Device Onboard (FDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The FIDO Device Onboard project provides the manufacturer component sample for manufacturers (OEMs, ODMs, or 3rd party integrators) to enable FDO on their devices. This document details how a manufacturer can use this tool to produce an FDO-enabled device. Terminology \u00b6 Refer to the FIDO Device Onboard Reference page . Overview \u00b6 To Integrate FIDO Device Onboard (FDO)-services into a Device Management Service (DMS), a DMS must host an Owner service, manage owner cryptographic keys, ingest ownership vouchers from a supply chain, and provide onboarding and onboarding solution in the form of service info instructions. For details on how to setup and initialize the Owner Service Component Sample see the Readme included with this sample as part of the FDO software [Owner Component Readme] (https://github.com/secure-device-onboard/pri-fidoiot/tree/master/component-samples/demo/owner/README.md). Owner Component Sample \u00b6 The main function of the Owner component sample is to serve as a TO2 protocol server. The owner component sample runs as a web service and makes use of the FDO H2 database for configuration and storage of ownership vouchers. All configuration and data for the owner is stored in this H2 database and property or environment files. All-in-One (AIO) Component Sample \u00b6 In addition to the owner component, the All-in-one component can be used to host Owner, Rendezvous, and Manufacturing services all in one service. This makes deploying and testing of FDO easier. Evaluation Deployment \u00b6 The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems. DMS Integration using Service Info \u00b6 Owner component service info can integrate with a DMS by providing the following: -A script to download the agent used to connect to the DMS -The Agent Credentials to download (for example, certificates or one time tokens) -Any connection information such as scope ID, URL, or tenant information. NOTE : Service info is always encrypted even if http protocol is being used for To2 Protocol. DMS Credential Creation \u00b6 DMS credentials can be created at the time of ownership voucher injection or when the device is running the To2 protocol. To Do: \u00b6 Setup local Azure CLI https://docs.microsoft.com/en-us/cli/azure/run-azure-cli-docker \u00b6 https://docs.microsoft.com/en-us/rest/api/iothub/device/createfileuploadsasuri \u00b6 Create a bash to create a device with on Azure using the bash script Use the device uuid as the name Steps: 1. Run CLI docker a. https://docs.microsoft.com/en-us/cli/azure/run-azure-cli-docker b. \u201cdocker run -it -v ${HOME}/.ssh:/root/.ssh -v ~/Desktop/dev/Azure:/home mcr.microsoft.com/azure-cli\u201d 2. Log in to Azure account a. \u201caz login\u201d b. https://microsoft.com/devicelogin 3. Create a device place holder a. https://docs.microsoft.com/en-us/azure/iot-edge/how-to-manual-provision-symmetric-key?view=iotedge-2018-06&tabs=azure-cli%2Clinux b. \u201caz iot hub device-identity create --device-id [Device-name] --hub-name [hub-name] --edge-enabled\u201d i. Device-Name: UUID ii. Hub-name: FDO-Edge c. List of all devices registered i. \u201caz iot hub device-identity list --hub-name [hub name]\u201d d. Save the connection string i. az iot hub device-identity show-connection-string --device-id [device id] --hub-name [hub name] DPS: \u00b6 Device-Name: DEMO-DPS \u00b6 primary: SHA1 Fingerprint=8FE4F67B59533FEC6C3B6A2FD2BA658863F45BD5 \u00b6 secondary: SHA1 Fingerprint=68FFFFB9703ECBA49B273A417E4166253F3C7EE2 \u00b6 Azure/certs.sh \u00b6 Device: \u00b6 UsingFDO: Install Iot-edge containers on the target device \u00b6 UsingFDO: Inject the Connection String into config file \u00b6 UsingFDO: Restart IOTG containers \u00b6","title":"DMS Integration Guide"},{"location":"implementation-references/dms-integration-guide/#introduction","text":"FIDO Device Onboard (FDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The FIDO Device Onboard project provides the manufacturer component sample for manufacturers (OEMs, ODMs, or 3rd party integrators) to enable FDO on their devices. This document details how a manufacturer can use this tool to produce an FDO-enabled device.","title":"Introduction"},{"location":"implementation-references/dms-integration-guide/#terminology","text":"Refer to the FIDO Device Onboard Reference page .","title":"Terminology"},{"location":"implementation-references/dms-integration-guide/#overview","text":"To Integrate FIDO Device Onboard (FDO)-services into a Device Management Service (DMS), a DMS must host an Owner service, manage owner cryptographic keys, ingest ownership vouchers from a supply chain, and provide onboarding and onboarding solution in the form of service info instructions. For details on how to setup and initialize the Owner Service Component Sample see the Readme included with this sample as part of the FDO software [Owner Component Readme] (https://github.com/secure-device-onboard/pri-fidoiot/tree/master/component-samples/demo/owner/README.md).","title":"Overview"},{"location":"implementation-references/dms-integration-guide/#owner-component-sample","text":"The main function of the Owner component sample is to serve as a TO2 protocol server. The owner component sample runs as a web service and makes use of the FDO H2 database for configuration and storage of ownership vouchers. All configuration and data for the owner is stored in this H2 database and property or environment files.","title":"Owner Component Sample"},{"location":"implementation-references/dms-integration-guide/#all-in-one-aio-component-sample","text":"In addition to the owner component, the All-in-one component can be used to host Owner, Rendezvous, and Manufacturing services all in one service. This makes deploying and testing of FDO easier.","title":"All-in-One (AIO) Component Sample"},{"location":"implementation-references/dms-integration-guide/#evaluation-deployment","text":"The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems.","title":"Evaluation Deployment"},{"location":"implementation-references/dms-integration-guide/#dms-integration-using-service-info","text":"Owner component service info can integrate with a DMS by providing the following: -A script to download the agent used to connect to the DMS -The Agent Credentials to download (for example, certificates or one time tokens) -Any connection information such as scope ID, URL, or tenant information. NOTE : Service info is always encrypted even if http protocol is being used for To2 Protocol.","title":"DMS Integration using Service Info"},{"location":"implementation-references/dms-integration-guide/#dms-credential-creation","text":"DMS credentials can be created at the time of ownership voucher injection or when the device is running the To2 protocol.","title":"DMS Credential Creation"},{"location":"implementation-references/dms-integration-guide/#to-do","text":"Setup local Azure CLI","title":"To Do:"},{"location":"implementation-references/dms-integration-guide/#httpsdocsmicrosoftcomen-uscliazurerun-azure-cli-docker","text":"","title":"https://docs.microsoft.com/en-us/cli/azure/run-azure-cli-docker"},{"location":"implementation-references/dms-integration-guide/#httpsdocsmicrosoftcomen-usrestapiiothubdevicecreatefileuploadsasuri","text":"Create a bash to create a device with on Azure using the bash script Use the device uuid as the name Steps: 1. Run CLI docker a. https://docs.microsoft.com/en-us/cli/azure/run-azure-cli-docker b. \u201cdocker run -it -v ${HOME}/.ssh:/root/.ssh -v ~/Desktop/dev/Azure:/home mcr.microsoft.com/azure-cli\u201d 2. Log in to Azure account a. \u201caz login\u201d b. https://microsoft.com/devicelogin 3. Create a device place holder a. https://docs.microsoft.com/en-us/azure/iot-edge/how-to-manual-provision-symmetric-key?view=iotedge-2018-06&tabs=azure-cli%2Clinux b. \u201caz iot hub device-identity create --device-id [Device-name] --hub-name [hub-name] --edge-enabled\u201d i. Device-Name: UUID ii. Hub-name: FDO-Edge c. List of all devices registered i. \u201caz iot hub device-identity list --hub-name [hub name]\u201d d. Save the connection string i. az iot hub device-identity show-connection-string --device-id [device id] --hub-name [hub name]","title":"https://docs.microsoft.com/en-us/rest/api/iothub/device/createfileuploadsasuri"},{"location":"implementation-references/dms-integration-guide/#dps","text":"","title":"DPS:"},{"location":"implementation-references/dms-integration-guide/#device-name-demo-dps","text":"","title":"Device-Name: DEMO-DPS"},{"location":"implementation-references/dms-integration-guide/#primary-sha1-fingerprint8fe4f67b59533fec6c3b6a2fd2ba658863f45bd5","text":"","title":"primary:  SHA1 Fingerprint=8FE4F67B59533FEC6C3B6A2FD2BA658863F45BD5"},{"location":"implementation-references/dms-integration-guide/#secondary-sha1-fingerprint68ffffb9703ecba49b273a417e4166253f3c7ee2","text":"","title":"secondary: SHA1 Fingerprint=68FFFFB9703ECBA49B273A417E4166253F3C7EE2"},{"location":"implementation-references/dms-integration-guide/#azurecertssh","text":"","title":"Azure/certs.sh"},{"location":"implementation-references/dms-integration-guide/#device","text":"","title":"Device:"},{"location":"implementation-references/dms-integration-guide/#usingfdo-install-iot-edge-containers-on-the-target-device","text":"","title":"UsingFDO: Install Iot-edge containers on the target device"},{"location":"implementation-references/dms-integration-guide/#usingfdo-inject-the-connection-string-into-config-file","text":"","title":"UsingFDO: Inject the Connection String into config file"},{"location":"implementation-references/dms-integration-guide/#usingfdo-restart-iotg-containers","text":"","title":"UsingFDO: Restart IOTG containers"},{"location":"implementation-references/getting-started-guide/","text":"NOTE : This is a preliminary implementation of the FIDO Device Onboard Spec published by the FIDO Alliance. The implementation is experimental and incomplete, and is not ready for use in any production capacity. Some cryptographic algorithms and encoding formats have not been implemented, and any aspect of this implementation is subject to change. Getting Started Guide \u00b6 FDO (FIDO device onboard) provides a fast and more secure way to onboard a device to any device management system. A unique feature of FDO is the ability for the device owner to select the IoT platform at a late stage in the device life cycle. The secrets or configuration data may also be created or chosen at this late stage. This document provides a quick walk through the E2E flow. Included in this guide: Building FDO PRI Source Starting FDO Service Containers Running E2E for PRI device Building Client-SDK Source Running E2E for Client-SDK device Enabling ServiceInfo Keystore Management Building FDO PRI Source \u00b6 Notes Check the System Requirements If working behind a proxy, ensure to set proper proxy variables. Follow the steps to setup Docker* environment. Read more about PRI source building. Follow the steps to set the right proxy settings. (Includes documentation for system wide proxy configuration) 1. Clone the PRI-fidoiot repository git clone https://github.com/secure-device-onboard/pri-fidoiot.git 2. Build PRI-fidoiot: FDO PRI source can be built in two ways: Note For the instructions in this document, <fdo-pri-src> refers to the path of the FDO PRI folder 'pri-fidoiot'. Using the Maven build system to build FDO PRI source. cd <fdo-pri-src> mvn clean install 2. Using Docker container to build FDO PRI source cd <fdo-pri-src>/build sudo docker-compose up --build The build stage generates artifacts and stores them in component-samples/demo directory. NOTE: During the build stage, the following error messages may be displayed on the console. These error messages are a result of the discrepancy of logging levels during the build stage and can be ignored. [ERROR] Picked up _JAVA_OPTIONS: -Dhttp.proxyHost= -Dhttp.proxyPort= -Dhttps.proxyHost= -Dhttps.proxyPort= [ERROR] WARNING: An illegal reflective access operation has occurred [ERROR] WARNING: Illegal reflective access by org.apache.catalina.loader.WebappClassLoaderBase to field java.io.ObjectStreamClass$Caches.localDescs [ERROR] WARNING: Please consider reporting this to the maintainers of org.apache.catalina.loader.WebappClassLoaderBase [ERROR] WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations [ERROR] WARNING: All illegal access operations will be denied in a future release Starting FDO Server-side Containers \u00b6 FIDO Device Onboard Entities and Entity Interconnection Key Generation for FDO Server-side Containers \u00b6 Run the below commands to generate all the required keys for the Server-side containers. cd <fdo-pri-src>/component-samples/demo/scripts/ bash keys_gen.sh . cp -r creds/* ../ All the generated keys are now copied to the respective components. Starting the FDO PRI Manufacturer Server \u00b6 FDO Manufacturer is an application that runs in the factory, which implements the initial communications with the Device, as part of the Device Initialize Protocol (DI). The manufacturer creates an Ownership Voucher based on the credentials received during DI and extends the voucher to the respective owner. Run the below commands, in a separate console, to start the Manufacturer. cd <fdo-pri-src>/component-samples/demo/manufacturer/ sudo docker-compose up --build Once the Manufacturer has successfully started, the following output is displayed Manufacturer getting started Starting the FDO PRI Rendezvous (RV) Server \u00b6 RV Server is a network server or service (For example, on the Internet) that acts as a rendezvous point between a newly powered on Device and the Owner Onboarding Service. Run the below commands, on a seperate console, to start the RV server. cd <fdo-pri-src>/component-samples/demo/rv/ sudo docker-compose up --build Once the RV instance has successfully started, the following output is displayed RV getting started Starting the FDO PRI Owner Server \u00b6 Owner is an entity that is able to prove ownership to the Device using an Ownership Voucher and a private key for the last entry of the Ownership Voucher. Owner supports the transfer of Serviceinfo to the Device. Run the below commands, on a separate console, to start the Owner Server. cd <fdo-pri-src>/component-samples/demo/owner/ sudo docker-compose up --build Once the Owner instance has successfully started, the following output is displayed Owner getting started Note Proper keystore management to be considered before using the services in production environment. To0scheduling interval property can be modified in the component-sample/demo/owner/owner.env. Update owner_to0_scheduling_interval=30 Read more about starting PRI services. Running E2E for PRI Device \u00b6 Start FDO Service Containers . Start Device Initialization (DI) DI includes the insertion of FDO credentials into device during the manufacturing process and creation of ownership voucher. On a new console, key in the following commands cd <fdo-pri-src>/component-samples/demo/device java -jar device.jar Expect the following line on successful DI completion. DI complete, GUID is <guid> Note Additional arguments for configuring PRI device . Configuring PRI device for HTTPS/TLS communication . Read more about Device Intialization. 3. Voucher Extension & TO0 for PRI Device Voucher extension During TO0, the FDO Owner identifies itself to Rendezvous Server, establishes the mapping of GUID to the Owner IP address. TO0 ends with RV Server having an entry in a table that associates the Device GUID with the Owner Service\u2019s rendezvous 'blob.' curl -D - --digest -u apiUser:MfgApiPass123 -XGET http://localhost:8039/api/v1/vouchers/0 -o voucher curl -D - --digest -u apiUser:OwnerApiPass123 --header \"Content-Type: application/cbor\" --data-binary @voucher http://localhost:8042/api/v1/owner/vouchers/ Make sure you are getting status 200 OK for the curl calls. If you are facing issue with localhost curl calls, try with IP address instead of localhost. Wait for TO0 finished for message in the Owner console. This generally takes a few minutes to complete. Expect the following message on successful TO0 completion. TO0 Response Wait for <guid> : 3600 TO0 Client finished for GUID <guid> Note Keystore Management needs to be taken care, if PRI Rendezvous server and PRI Owner server is not running on the same machine. You can enable ServiceInfo at this stage. Follow the instructions to enable ServiceInfo. In the above commands, if the return value is 500 , replace localhost with the IP address of the machine. 4. TO1 and TO2 During T01, Device identifies itself to the Rendezvous Server. Obtains mapping to connect to the Owner\u2019s IP address. During T02, the Device contacts Owner and establishes trust and then performs Ownership Transfer. cd <fdo-pri-src>/component-samples/demo/device java -jar device.jar Wait for TO2 protocol completed message and Device is onboarded Successfully. Expect the following message on successful TO2 completion. TO2 complete, GUID is d43c6dc6... Building Client-SDK Source \u00b6 FDO Client-SDK source can be build by: Follow instructions in the documentation to install dependencies. Clone the repository git clone https://github.com/secure-device-onboard/client-sdk-fidoiot.git Note For the instructions in this document, <client-sdk-src> refers to the path of the FDO Client-SDK source folder 'client-sdk-fidoiot'. 3. Execute build.sh script cd <client-sdk-src> ./build.sh The build script generates artifacts and stores them in ./build/ directory. Running E2E Demo for FDO Client-SDK. \u00b6 Start FDO Service Containers . Start Device Initialization (DI) cd <client-sdk-src> ./build/linux-client Note Read more on Client-SDK Device Initialization. Configuring Client-SDK device for Proxy Network. Follow instructions in the documentation , to update Manufacturer's address. 3. Voucher Extension for Client-SDK Device curl -D - --digest -u apiUser:MfgApiPass123 -XGET http://localhost:8039/api/v1/vouchers/abcdef -o voucher curl -D - --digest -u apiUser:OwnerApiPass123 --header \"Content-Type: application/cbor\" --data-binary @voucher http://localhost:8042/api/v1/owner/vouchers/ Make sure you are getting status 200 OK for the curl calls. If you are facing issue with localhost curl calls, try with IP address instead of localhost. Wait for TO0 to finish for message on the Owner console. Expect the following message on successful TO0 completion. TO0 Response Wait for <guid> : 3600 TO0 Client finished for GUID <guid> Note Keystore Management needs to be taken care, if PRI Rendezvous server and PRI Owner server is not running on the same machine. You can enable ServiceInfo at this stage. Follow the instructions to enable ServiceInfo. 4. TO1 and TO2 cd <client-sdk-src> ./build/linux-client Wait for TO2 protocol completed message Expect the following message on successful TO completion. Device onboarded successfully. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @FIDO Device Onboard Complete@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Enabling ServiceInfo Transfer \u00b6 Activating ServiceInfo Module. $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=active&priority=0&bytes=F5' --header 'Content-Type: application/octet-stream' In this example, we are activating fdo_sys module. http://localhost:8042 can be changed with the IP address of the owner. 2. Transferring payload or executable resource for a specific type of device. Create a sample linux64.sh shell script. #!/bin/bash wget https://raw.githubusercontent.com/secure-device-onboard/pri-fidoiot/master/SECURITY.md filename=SECURITY.md cksum_tx=2749598590 cksum_rx=$(cksum $filename | cut -d ' ' -f 1) if [ $cksum_tx -eq $cksum_rx ]; then echo \"Device onboarded successfully.\" echo \"Device onboarded successfully.\" > result.txt else echo \"ServiceInfo file transmission failed.\" echo \"ServiceInfo file transmission failed.\" > result.txt fi This script downloads the SECURITY.md file and checks the integrity of file against the pre-computed checksum value. Curl command to transfer executable resource. $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=filedesc&priority=1&filename=linux64.sh&device=FDO-Pri-Device' --header 'Content-Type: application/octet-stream' --data-binary '@path-to-executable/linux64.sh' for Client-SDK devices, update device parameter to Intel-FDO-Linux . Eg: $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=filedesc&priority=1&filename=linux64.sh&device=Intel-FDO-Linux' --header 'Content-Type: application/octet-stream' --data-binary '@path-to-executable/linux64.sh' 3. Curl command to add exec command on the transferred script $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=exec&guid=<guid-of-device>&priority=2&bytes=82672F62696E2F73686A6C696E757836342E7368' --header 'Content-Type: application/octet-stream' Note bytes parameter is the cbor equivalent of ./linux64.sh. You can skip step 3, if you are just transferring a payload. Keystore Management \u00b6 Generating Self-signed keys for HTTPS/TLS Communication. \u00b6 Generate key and certificate. openssl req \\ -x509 \\ -newkey rsa:2048 \\ -sha256 \\ -days 3560 \\ -nodes \\ -keyout tls.key \\ -out tls.crt \\ -subj '/CN=fdo' \\ -extensions san \\ -config <( \\ echo '[req]'; \\ echo 'distinguished_name=req'; \\ echo '[san]'; \\ echo 'subjectAltName=DNS:localhost,IP:<ip-address>') Update <ip-address> with the IP address of machine running the FDO service. Generate Keystore using fresh key and certificate. openssl pkcs12 -export -in tls.crt -inkey tls.key -out ssl.p12 Copy the ssl.p12 file into component-samples/demo/<component>/certs/ folder. Update the respective .env file with proper keystore credentials. Adding generated certificate into the truststore. keytool -import -alias fdo -file tls.crt -storetype PKCS12 -keystore truststore Note Read more about key generation. You can update the key type, by modifying the -newkey attribute during the key generation stage. You can add multiple IP addresses in the subjectAltName attribute.","title":"Getting Started Guide"},{"location":"implementation-references/getting-started-guide/#getting-started-guide","text":"FDO (FIDO device onboard) provides a fast and more secure way to onboard a device to any device management system. A unique feature of FDO is the ability for the device owner to select the IoT platform at a late stage in the device life cycle. The secrets or configuration data may also be created or chosen at this late stage. This document provides a quick walk through the E2E flow. Included in this guide: Building FDO PRI Source Starting FDO Service Containers Running E2E for PRI device Building Client-SDK Source Running E2E for Client-SDK device Enabling ServiceInfo Keystore Management","title":"Getting Started Guide"},{"location":"implementation-references/getting-started-guide/#building-fdo-pri-source","text":"Notes Check the System Requirements If working behind a proxy, ensure to set proper proxy variables. Follow the steps to setup Docker* environment. Read more about PRI source building. Follow the steps to set the right proxy settings. (Includes documentation for system wide proxy configuration) 1. Clone the PRI-fidoiot repository git clone https://github.com/secure-device-onboard/pri-fidoiot.git 2. Build PRI-fidoiot: FDO PRI source can be built in two ways: Note For the instructions in this document, <fdo-pri-src> refers to the path of the FDO PRI folder 'pri-fidoiot'. Using the Maven build system to build FDO PRI source. cd <fdo-pri-src> mvn clean install 2. Using Docker container to build FDO PRI source cd <fdo-pri-src>/build sudo docker-compose up --build The build stage generates artifacts and stores them in component-samples/demo directory. NOTE: During the build stage, the following error messages may be displayed on the console. These error messages are a result of the discrepancy of logging levels during the build stage and can be ignored. [ERROR] Picked up _JAVA_OPTIONS: -Dhttp.proxyHost= -Dhttp.proxyPort= -Dhttps.proxyHost= -Dhttps.proxyPort= [ERROR] WARNING: An illegal reflective access operation has occurred [ERROR] WARNING: Illegal reflective access by org.apache.catalina.loader.WebappClassLoaderBase to field java.io.ObjectStreamClass$Caches.localDescs [ERROR] WARNING: Please consider reporting this to the maintainers of org.apache.catalina.loader.WebappClassLoaderBase [ERROR] WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations [ERROR] WARNING: All illegal access operations will be denied in a future release","title":"Building FDO PRI Source"},{"location":"implementation-references/getting-started-guide/#starting-fdo-server-side-containers","text":"FIDO Device Onboard Entities and Entity Interconnection","title":"Starting FDO Server-side Containers"},{"location":"implementation-references/getting-started-guide/#key-generation-for-fdo-server-side-containers","text":"Run the below commands to generate all the required keys for the Server-side containers. cd <fdo-pri-src>/component-samples/demo/scripts/ bash keys_gen.sh . cp -r creds/* ../ All the generated keys are now copied to the respective components.","title":"Key Generation for FDO Server-side Containers"},{"location":"implementation-references/getting-started-guide/#starting-the-fdo-pri-manufacturer-server","text":"FDO Manufacturer is an application that runs in the factory, which implements the initial communications with the Device, as part of the Device Initialize Protocol (DI). The manufacturer creates an Ownership Voucher based on the credentials received during DI and extends the voucher to the respective owner. Run the below commands, in a separate console, to start the Manufacturer. cd <fdo-pri-src>/component-samples/demo/manufacturer/ sudo docker-compose up --build Once the Manufacturer has successfully started, the following output is displayed Manufacturer getting started","title":"Starting the FDO PRI Manufacturer Server"},{"location":"implementation-references/getting-started-guide/#starting-the-fdo-pri-rendezvous-rv-server","text":"RV Server is a network server or service (For example, on the Internet) that acts as a rendezvous point between a newly powered on Device and the Owner Onboarding Service. Run the below commands, on a seperate console, to start the RV server. cd <fdo-pri-src>/component-samples/demo/rv/ sudo docker-compose up --build Once the RV instance has successfully started, the following output is displayed RV getting started","title":"Starting the FDO PRI Rendezvous (RV) Server"},{"location":"implementation-references/getting-started-guide/#starting-the-fdo-pri-owner-server","text":"Owner is an entity that is able to prove ownership to the Device using an Ownership Voucher and a private key for the last entry of the Ownership Voucher. Owner supports the transfer of Serviceinfo to the Device. Run the below commands, on a separate console, to start the Owner Server. cd <fdo-pri-src>/component-samples/demo/owner/ sudo docker-compose up --build Once the Owner instance has successfully started, the following output is displayed Owner getting started Note Proper keystore management to be considered before using the services in production environment. To0scheduling interval property can be modified in the component-sample/demo/owner/owner.env. Update owner_to0_scheduling_interval=30 Read more about starting PRI services.","title":"Starting the FDO PRI Owner Server"},{"location":"implementation-references/getting-started-guide/#running-e2e-for-pri-device","text":"Start FDO Service Containers . Start Device Initialization (DI) DI includes the insertion of FDO credentials into device during the manufacturing process and creation of ownership voucher. On a new console, key in the following commands cd <fdo-pri-src>/component-samples/demo/device java -jar device.jar Expect the following line on successful DI completion. DI complete, GUID is <guid> Note Additional arguments for configuring PRI device . Configuring PRI device for HTTPS/TLS communication . Read more about Device Intialization. 3. Voucher Extension & TO0 for PRI Device Voucher extension During TO0, the FDO Owner identifies itself to Rendezvous Server, establishes the mapping of GUID to the Owner IP address. TO0 ends with RV Server having an entry in a table that associates the Device GUID with the Owner Service\u2019s rendezvous 'blob.' curl -D - --digest -u apiUser:MfgApiPass123 -XGET http://localhost:8039/api/v1/vouchers/0 -o voucher curl -D - --digest -u apiUser:OwnerApiPass123 --header \"Content-Type: application/cbor\" --data-binary @voucher http://localhost:8042/api/v1/owner/vouchers/ Make sure you are getting status 200 OK for the curl calls. If you are facing issue with localhost curl calls, try with IP address instead of localhost. Wait for TO0 finished for message in the Owner console. This generally takes a few minutes to complete. Expect the following message on successful TO0 completion. TO0 Response Wait for <guid> : 3600 TO0 Client finished for GUID <guid> Note Keystore Management needs to be taken care, if PRI Rendezvous server and PRI Owner server is not running on the same machine. You can enable ServiceInfo at this stage. Follow the instructions to enable ServiceInfo. In the above commands, if the return value is 500 , replace localhost with the IP address of the machine. 4. TO1 and TO2 During T01, Device identifies itself to the Rendezvous Server. Obtains mapping to connect to the Owner\u2019s IP address. During T02, the Device contacts Owner and establishes trust and then performs Ownership Transfer. cd <fdo-pri-src>/component-samples/demo/device java -jar device.jar Wait for TO2 protocol completed message and Device is onboarded Successfully. Expect the following message on successful TO2 completion. TO2 complete, GUID is d43c6dc6...","title":"Running E2E for PRI Device"},{"location":"implementation-references/getting-started-guide/#building-client-sdk-source","text":"FDO Client-SDK source can be build by: Follow instructions in the documentation to install dependencies. Clone the repository git clone https://github.com/secure-device-onboard/client-sdk-fidoiot.git Note For the instructions in this document, <client-sdk-src> refers to the path of the FDO Client-SDK source folder 'client-sdk-fidoiot'. 3. Execute build.sh script cd <client-sdk-src> ./build.sh The build script generates artifacts and stores them in ./build/ directory.","title":"Building Client-SDK Source"},{"location":"implementation-references/getting-started-guide/#running-e2e-demo-for-fdo-client-sdk","text":"Start FDO Service Containers . Start Device Initialization (DI) cd <client-sdk-src> ./build/linux-client Note Read more on Client-SDK Device Initialization. Configuring Client-SDK device for Proxy Network. Follow instructions in the documentation , to update Manufacturer's address. 3. Voucher Extension for Client-SDK Device curl -D - --digest -u apiUser:MfgApiPass123 -XGET http://localhost:8039/api/v1/vouchers/abcdef -o voucher curl -D - --digest -u apiUser:OwnerApiPass123 --header \"Content-Type: application/cbor\" --data-binary @voucher http://localhost:8042/api/v1/owner/vouchers/ Make sure you are getting status 200 OK for the curl calls. If you are facing issue with localhost curl calls, try with IP address instead of localhost. Wait for TO0 to finish for message on the Owner console. Expect the following message on successful TO0 completion. TO0 Response Wait for <guid> : 3600 TO0 Client finished for GUID <guid> Note Keystore Management needs to be taken care, if PRI Rendezvous server and PRI Owner server is not running on the same machine. You can enable ServiceInfo at this stage. Follow the instructions to enable ServiceInfo. 4. TO1 and TO2 cd <client-sdk-src> ./build/linux-client Wait for TO2 protocol completed message Expect the following message on successful TO completion. Device onboarded successfully. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @FIDO Device Onboard Complete@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@","title":"Running E2E Demo for FDO Client-SDK."},{"location":"implementation-references/getting-started-guide/#enabling-serviceinfo-transfer","text":"Activating ServiceInfo Module. $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=active&priority=0&bytes=F5' --header 'Content-Type: application/octet-stream' In this example, we are activating fdo_sys module. http://localhost:8042 can be changed with the IP address of the owner. 2. Transferring payload or executable resource for a specific type of device. Create a sample linux64.sh shell script. #!/bin/bash wget https://raw.githubusercontent.com/secure-device-onboard/pri-fidoiot/master/SECURITY.md filename=SECURITY.md cksum_tx=2749598590 cksum_rx=$(cksum $filename | cut -d ' ' -f 1) if [ $cksum_tx -eq $cksum_rx ]; then echo \"Device onboarded successfully.\" echo \"Device onboarded successfully.\" > result.txt else echo \"ServiceInfo file transmission failed.\" echo \"ServiceInfo file transmission failed.\" > result.txt fi This script downloads the SECURITY.md file and checks the integrity of file against the pre-computed checksum value. Curl command to transfer executable resource. $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=filedesc&priority=1&filename=linux64.sh&device=FDO-Pri-Device' --header 'Content-Type: application/octet-stream' --data-binary '@path-to-executable/linux64.sh' for Client-SDK devices, update device parameter to Intel-FDO-Linux . Eg: $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=filedesc&priority=1&filename=linux64.sh&device=Intel-FDO-Linux' --header 'Content-Type: application/octet-stream' --data-binary '@path-to-executable/linux64.sh' 3. Curl command to add exec command on the transferred script $ curl --location --digest -u apiUser:OwnerApiPass123 --request PUT 'http://localhost:8042/api/v1/device/svi?module=fdo_sys&var=exec&guid=<guid-of-device>&priority=2&bytes=82672F62696E2F73686A6C696E757836342E7368' --header 'Content-Type: application/octet-stream' Note bytes parameter is the cbor equivalent of ./linux64.sh. You can skip step 3, if you are just transferring a payload.","title":"Enabling ServiceInfo Transfer"},{"location":"implementation-references/getting-started-guide/#keystore-management","text":"","title":"Keystore Management"},{"location":"implementation-references/getting-started-guide/#generating-self-signed-keys-for-httpstls-communication","text":"Generate key and certificate. openssl req \\ -x509 \\ -newkey rsa:2048 \\ -sha256 \\ -days 3560 \\ -nodes \\ -keyout tls.key \\ -out tls.crt \\ -subj '/CN=fdo' \\ -extensions san \\ -config <( \\ echo '[req]'; \\ echo 'distinguished_name=req'; \\ echo '[san]'; \\ echo 'subjectAltName=DNS:localhost,IP:<ip-address>') Update <ip-address> with the IP address of machine running the FDO service. Generate Keystore using fresh key and certificate. openssl pkcs12 -export -in tls.crt -inkey tls.key -out ssl.p12 Copy the ssl.p12 file into component-samples/demo/<component>/certs/ folder. Update the respective .env file with proper keystore credentials. Adding generated certificate into the truststore. keytool -import -alias fdo -file tls.crt -storetype PKCS12 -keystore truststore Note Read more about key generation. You can update the key type, by modifying the -newkey attribute during the key generation stage. You can add multiple IP addresses in the subjectAltName attribute.","title":"Generating Self-signed keys for HTTPS/TLS Communication."},{"location":"implementation-references/manufacturer-guide/","text":"Introduction \u00b6 FIDO Device Onboard (FDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The FIDO Device Onboard project provides the manufacturer component sample for manufacturers (OEMs, ODMs, or 3rd party integrators) to enable FDO on their devices. This document details how a manufacturer can use this tool to produce an FDO-enabled device. Terminology \u00b6 Refer to the FIDO Device Onboard Reference page . Overview \u00b6 To produce FIDO Device Onboard (FDO)-enabled devices, a manufacturer must run the FIDO device initialization (DI) protocol on the device. The DI process sets security credentials in secure storage in the device and creates the initial ownership voucher. The manufacturer makes use of the provided tools for this process: a manufacturer component sample (which includes an embedded H2 database), and software that runs on the device to perform DI. The manufacturer component sample acts as a DI server for the devices. After running DI on the device, the resulting ownership voucher is stored in the H2 Database. At this point, the FDO security credentials have been stored in the device and the device is FDO ready. When the device is sold to a customer, the ownership voucher is extended and shipped along with the device. A complete integration and deployment of FDO in a manufacturing environment requires a fair amount of planning and effort. However, for development, test, and enabling purposes, a much simpler evaluation deployment can be done. For details on how to setup and initialize the Manufacturer Component Sample see the Readme included with this sample as part of the FDO software [Manufacturer Component Readme] (https://github.com/secure-device-onboard/pri-fidoiot/tree/master/component-samples/demo/manufacturer/README.md). Manufacturer Component Sample \u00b6 The main function of the manufacturer component sample is to serve as a DI protocol server. The manufacturer component sample runs as a web service and makes use of the FDO H2 database for configuration and storage of ownership vouchers. All configuration and data for the manufacturer is stored in this H2 database and property or environment files. Evaluation Deployment \u00b6 The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems. Step 1: Prepare Hardware Infrastructure \u00b6 You need to have one machine that can run the manufacturer component sample. A non-production environment has minimal requirements; the machine can run either the Linux* OS (version 20.04) or Windows* 10 OS. Step 2: Component sample installation \u00b6 Install the manufacturer component sample, see Manufacturer Component Readme for details. Step 3: Test \u00b6 Set up the device to run the FDO DI protocol (refer to device specific documentation for details). Run DI on the device against the manufacturer component sample. You can use any value for the device serial no at this point. For a production scenario, see Device Serial No for details. Use the REST APIs (or a database management tool) to view and confirm the ownership voucher has been created. Production Deployment \u00b6 A production deployment requires all steps of an evaluation deployment with the addition of integration with the manufacturing business systems. In addition, the manufacturer component sample is just a sample and will require further enchancements to make it production worthy. Device Serial No \u00b6 Since a device identifier (typically, a serial no) is required for the DI protocol, it is recommended that there be some programmatic mechanism to determine the serial no of a device. This value can then be passed to the FDO client software to be encorporated into the appropriate DI message. This may require modifications to your existing manufacturing workflow. Manage FDO public key(s) from customers, and the public key(s) storage in the H2 database. \u00b6 FDO requires that a customer create (or make use of existing) a key pair to use for extending ownership vouchers. The public key of this pair must be provided to the manufacturer to use for extending the voucher to that customer. Your customer interactions and processes must be modified as required to support this receipt of their public key and then to import this key into the manufacturer component sample. Whether this key is delivered with each order or done before separately depends on your processes and interaction with your customers. Note: depending on the type of devices you manufacture, more than one type of key pair may be required (i.e. ECC384, RSA256, etc.). Oownership Vouchers Management \u00b6 After a device is initialized with FDO, an initial ownership voucher is produced and stored in the database. This voucher must first be \u201csigned\u201d (extended) to a customer before sending to the customer. The ownership voucher management task has the following two steps: 1. Assign a voucher (device) to a customer (technically, a customer public key). 2. Perform voucher extension. The resulting extended voucher can then be sent to the customer. The following are the implied requirements: 1. It is assumed that you already have some process to track which device was shipped with which order. Most likely, this is done with serial numbers. With FDO, there is an additional requirement that you match voucher(s) with physical devices such that the voucher(s) delivered to the customer are those that correspond to the actual physical devices that are delivered. 2. You need to update or modify the existing B2B channel to include an ownership voucher for each physical device delivered to the customer. Typically, these vouchers would be linked to the order in a particular way but the details will vary for each manufacturer. 3. If a customer loses one of these vouchers and requires a replacement, then you must re-generate this voucher (requires physical access to the device) or retrieve the voucher from the stored data if chose to store the extended voucher. Security Considerations \u00b6 The network used to connect devices to the manufacturer component sample must be on a closed network. Since DI is used to set security credentials into the device, it is vunerable to attacks if exposed externally. The key pair used by the manufacturer to extend vouchers must be stored securely. It is recommended that the system that stores the keystore file be secured from physical access to only qualified individuals. Supply Chain Requirements \u00b6 FDO requires support from your supply chain partners. Specially, they will need to deploy the means to manage and extend ownership vouchers. As physical devices come into their inventory they will need to associate those devices with the respective ownership vouchers. Then as those device are resold, the vouchers will need to be extended to the next owner in the supply chain. To support this process, there is a reseller component sample that can perform the storage and extension of ownership vouchers. See [Component Reseller] (https://github.com/secure-device-onboard/pri-fidoiot/tree/master/component-samples/reseller) for details.","title":"Manufacturer Guide"},{"location":"implementation-references/manufacturer-guide/#introduction","text":"FIDO Device Onboard (FDO) enhances the out-of-the-box setup and provisioning experience for connected IoT devices. The FIDO Device Onboard project provides the manufacturer component sample for manufacturers (OEMs, ODMs, or 3rd party integrators) to enable FDO on their devices. This document details how a manufacturer can use this tool to produce an FDO-enabled device.","title":"Introduction"},{"location":"implementation-references/manufacturer-guide/#terminology","text":"Refer to the FIDO Device Onboard Reference page .","title":"Terminology"},{"location":"implementation-references/manufacturer-guide/#overview","text":"To produce FIDO Device Onboard (FDO)-enabled devices, a manufacturer must run the FIDO device initialization (DI) protocol on the device. The DI process sets security credentials in secure storage in the device and creates the initial ownership voucher. The manufacturer makes use of the provided tools for this process: a manufacturer component sample (which includes an embedded H2 database), and software that runs on the device to perform DI. The manufacturer component sample acts as a DI server for the devices. After running DI on the device, the resulting ownership voucher is stored in the H2 Database. At this point, the FDO security credentials have been stored in the device and the device is FDO ready. When the device is sold to a customer, the ownership voucher is extended and shipped along with the device. A complete integration and deployment of FDO in a manufacturing environment requires a fair amount of planning and effort. However, for development, test, and enabling purposes, a much simpler evaluation deployment can be done. For details on how to setup and initialize the Manufacturer Component Sample see the Readme included with this sample as part of the FDO software [Manufacturer Component Readme] (https://github.com/secure-device-onboard/pri-fidoiot/tree/master/component-samples/demo/manufacturer/README.md).","title":"Overview"},{"location":"implementation-references/manufacturer-guide/#manufacturer-component-sample","text":"The main function of the manufacturer component sample is to serve as a DI protocol server. The manufacturer component sample runs as a web service and makes use of the FDO H2 database for configuration and storage of ownership vouchers. All configuration and data for the manufacturer is stored in this H2 database and property or environment files.","title":"Manufacturer Component Sample"},{"location":"implementation-references/manufacturer-guide/#evaluation-deployment","text":"The evaluation deployment is useful for development, test, and enabling purposes. The evaluation deployment can fully initialize a device to the same extent as the production deployment but does not require any integration with business systems.","title":"Evaluation Deployment"},{"location":"implementation-references/manufacturer-guide/#step-1-prepare-hardware-infrastructure","text":"You need to have one machine that can run the manufacturer component sample. A non-production environment has minimal requirements; the machine can run either the Linux* OS (version 20.04) or Windows* 10 OS.","title":"Step 1: Prepare Hardware Infrastructure"},{"location":"implementation-references/manufacturer-guide/#step-2-component-sample-installation","text":"Install the manufacturer component sample, see Manufacturer Component Readme for details.","title":"Step 2: Component sample installation"},{"location":"implementation-references/manufacturer-guide/#step-3-test","text":"Set up the device to run the FDO DI protocol (refer to device specific documentation for details). Run DI on the device against the manufacturer component sample. You can use any value for the device serial no at this point. For a production scenario, see Device Serial No for details. Use the REST APIs (or a database management tool) to view and confirm the ownership voucher has been created.","title":"Step 3: Test"},{"location":"implementation-references/manufacturer-guide/#production-deployment","text":"A production deployment requires all steps of an evaluation deployment with the addition of integration with the manufacturing business systems. In addition, the manufacturer component sample is just a sample and will require further enchancements to make it production worthy.","title":"Production Deployment"},{"location":"implementation-references/manufacturer-guide/#device-serial-no","text":"Since a device identifier (typically, a serial no) is required for the DI protocol, it is recommended that there be some programmatic mechanism to determine the serial no of a device. This value can then be passed to the FDO client software to be encorporated into the appropriate DI message. This may require modifications to your existing manufacturing workflow.","title":"Device Serial No"},{"location":"implementation-references/manufacturer-guide/#manage-fdo-public-keys-from-customers-and-the-public-keys-storage-in-the-h2-database","text":"FDO requires that a customer create (or make use of existing) a key pair to use for extending ownership vouchers. The public key of this pair must be provided to the manufacturer to use for extending the voucher to that customer. Your customer interactions and processes must be modified as required to support this receipt of their public key and then to import this key into the manufacturer component sample. Whether this key is delivered with each order or done before separately depends on your processes and interaction with your customers. Note: depending on the type of devices you manufacture, more than one type of key pair may be required (i.e. ECC384, RSA256, etc.).","title":"Manage FDO public key(s) from customers, and the public key(s) storage in the H2 database."},{"location":"implementation-references/manufacturer-guide/#oownership-vouchers-management","text":"After a device is initialized with FDO, an initial ownership voucher is produced and stored in the database. This voucher must first be \u201csigned\u201d (extended) to a customer before sending to the customer. The ownership voucher management task has the following two steps: 1. Assign a voucher (device) to a customer (technically, a customer public key). 2. Perform voucher extension. The resulting extended voucher can then be sent to the customer. The following are the implied requirements: 1. It is assumed that you already have some process to track which device was shipped with which order. Most likely, this is done with serial numbers. With FDO, there is an additional requirement that you match voucher(s) with physical devices such that the voucher(s) delivered to the customer are those that correspond to the actual physical devices that are delivered. 2. You need to update or modify the existing B2B channel to include an ownership voucher for each physical device delivered to the customer. Typically, these vouchers would be linked to the order in a particular way but the details will vary for each manufacturer. 3. If a customer loses one of these vouchers and requires a replacement, then you must re-generate this voucher (requires physical access to the device) or retrieve the voucher from the stored data if chose to store the extended voucher.","title":"Oownership Vouchers Management"},{"location":"implementation-references/manufacturer-guide/#security-considerations","text":"The network used to connect devices to the manufacturer component sample must be on a closed network. Since DI is used to set security credentials into the device, it is vunerable to attacks if exposed externally. The key pair used by the manufacturer to extend vouchers must be stored securely. It is recommended that the system that stores the keystore file be secured from physical access to only qualified individuals.","title":"Security Considerations"},{"location":"implementation-references/manufacturer-guide/#supply-chain-requirements","text":"FDO requires support from your supply chain partners. Specially, they will need to deploy the means to manage and extend ownership vouchers. As physical devices come into their inventory they will need to associate those devices with the respective ownership vouchers. Then as those device are resold, the vouchers will need to be extended to the next owner in the supply chain. To support this process, there is a reseller component sample that can perform the storage and extension of ownership vouchers. See [Component Reseller] (https://github.com/secure-device-onboard/pri-fidoiot/tree/master/component-samples/reseller) for details.","title":"Supply Chain Requirements"},{"location":"implementation-references/proxy-settings/","text":"Proxy Settings for Running FDO \u00b6 This document lists the different proxy settings that needs to be set In .bashrc \u00b6 Add this line export _JAVA_OPTIONS=\"-Dhttp.proxyHost=<proxy host> -Dhttp.proxyPort=<port> -Dhttps.proxyHost=<proxy host> -Dhttps.proxyPort=<port>\" Maven settings.xml \u00b6 Create a settings.xml file in ~/.m2 folder (if it does not already exist) and add the below content. Replace with the actual proxy host and port details. <settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0. http://maven.apache.org/xsd/settings-1.0.0.xsd\"> <proxies> <proxy> <id>http_proxy</id> <active>true</active> <protocol>http</protocol> <host><proxy host></host> <port> <port> </port> <username></username> <password></password> <nonProxyHosts>localhost|<proxy details></nonProxyHosts> </proxy> <proxy> <id>https_proxy</id> <active>true</active> <protocol>https</protocol> <host><proxy host></host> <port><port></port> <username></username> <password></password> <nonProxyHosts>localhost|<proxy></nonProxyHosts> </proxy> </proxies> </settings> In Dockerfile \u00b6 After successful PRI build, add the proxy settings to the Dockerfile file in the path /component-samples/demo/ ENV http_proxy <proxy host>:<port> ENV https_proxy <proxy host>:<port> Proxy Settings for Docker* \u00b6 Follow the proxy settings detailed here","title":"Proxy Setup Guide"},{"location":"implementation-references/proxy-settings/#proxy-settings-for-running-fdo","text":"This document lists the different proxy settings that needs to be set","title":"Proxy Settings for Running FDO"},{"location":"implementation-references/proxy-settings/#in-bashrc","text":"Add this line export _JAVA_OPTIONS=\"-Dhttp.proxyHost=<proxy host> -Dhttp.proxyPort=<port> -Dhttps.proxyHost=<proxy host> -Dhttps.proxyPort=<port>\"","title":"In .bashrc"},{"location":"implementation-references/proxy-settings/#maven-settingsxml","text":"Create a settings.xml file in ~/.m2 folder (if it does not already exist) and add the below content. Replace with the actual proxy host and port details. <settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0. http://maven.apache.org/xsd/settings-1.0.0.xsd\"> <proxies> <proxy> <id>http_proxy</id> <active>true</active> <protocol>http</protocol> <host><proxy host></host> <port> <port> </port> <username></username> <password></password> <nonProxyHosts>localhost|<proxy details></nonProxyHosts> </proxy> <proxy> <id>https_proxy</id> <active>true</active> <protocol>https</protocol> <host><proxy host></host> <port><port></port> <username></username> <password></password> <nonProxyHosts>localhost|<proxy></nonProxyHosts> </proxy> </proxies> </settings>","title":"Maven settings.xml"},{"location":"implementation-references/proxy-settings/#in-dockerfile","text":"After successful PRI build, add the proxy settings to the Dockerfile file in the path /component-samples/demo/ ENV http_proxy <proxy host>:<port> ENV https_proxy <proxy host>:<port>","title":"In Dockerfile"},{"location":"implementation-references/proxy-settings/#proxy-settings-for-docker","text":"Follow the proxy settings detailed here","title":"Proxy Settings for Docker*"},{"location":"implementation-references/serviceinfo-sys-module/","text":"This section defines the \u201csystem\u201d module (fdo_sys) specification which provides basic onboarding services for FDO capable devices. A module is a set of key-value pairs; they define the onboarding operations that can be performed on a given FDO device. Module key-value pairs are exchanged between the device and it\u2019s owning Device Management Service. It is up to the owning management service and the device to interpret the key-value pairs in accordance with the module specification. fdo_sys Module Definition \u00b6 The system module defines basic onboarding operations such as downloading content and executing commands. The following table describes key-value pairs for the system module. Key Name Value Meaning fdo_sys:active CBOR Bool True to activate the fdo_sys module. fdo_sys:exec CBOR Array of String values The command is put as array elements. The command performs a system call. fdo_sys:filedesc CBOR String Describes a path to a file that will be used in subsequent file operations. fdo_sys:write CBOR BSTR Appends a block of data to the current file description. fdo_sys:exec Message \u00b6 The fdo_sys:exec command performs a system call on the device. The value of this command is a CBOR Array of String values. The first string in the array is the command to execute and the remaining strings are the arguments to the command. It is expected that it would use \u201cexec\u201d (system call) or similar API to execute the command on the device. JSON* (readable description) [\"/bin/sh\",\"startup.sh\"] CBOR 82 # array(2) 67 # text(7) 2F62696E2F7368 # \"/bin/sh\" 6A # text(10) 737461727475702E7368 # \"startup.sh\" C example execvp(\u201c/bin/sh\u201d,(char* []) {\u201cshartup.sh\u201d}) fdo_sys:filedesc Message \u00b6 The fdo_sys:filedesc message describes the path to a file the will be used as a part of the onboarding process. A zero-length file is expected to exist on the local file system after this command is received. If the described file already exists, it is truncated to zero length, otherwise a zero-length file is created. The permissions for the created file is set to read/write for the user account the module is running under. File permissions can subsequently be modified with the fdo_sys:exec command if needed. If a path is not included as a part of the file name, the file is created under current working directory of the module. All subsequent fdo_sys:write operations will append to this file. If another fdo_sys:filedesc message is received, all subsequent fdo_sys:write messages will start appending to the file specified by the fdo_sys:filedesc message. fdo_sys:write Message \u00b6 The fdo_sys:write message provides an array of bytes that gets appended to the file described by the last fdo_sys:filedesc message. If this message is sent without being preceded by fdo_sys:filedesc, then a message 255: INVALID_MESSAGE_ERROR will be thrown and TO2 will not be completed. Once a fdo_sys:filedesc message has been received, many fdo_sys:write messages can follow. Examples \u00b6 Below are examples of the fdo_sys messages encoded as CBOR. The JSON examples are just human readable definitions while the actual messages are always CBOR. The encoding includes the entire TO2.OwnerServiceInfo message includes the isMore and isDone flags. Device should advertise it supports fdo_sys. NOTE : This example just includes the module list key value pairs and not all the required values for the devmod. DeviceServiceInfo (devmod) \u00b6 Diagnostic Notation (not used by protocol) [false, [[[\"devmod:active\", \"true\"], [\"devmod:nummodules\", 1], [\"devmod:modules\", [1, 1, \"fdo_sys\"]]]]] CBOR 82 # array(2) F4 # primitive(20) - IsMoreSeviceInfo 81 # array(1) - ServiceInfo 83 # array(3) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 1 6D # text(13) 6465766D6F643A616374697665 # \"devmod:active\" 64 # text(4) 74727565 # \"true\" 82 # array(2) - ServiceInfo Key-Value Pair 2 71 # text(17) 6465766D6F643A6E756D6D6F64756C6573 # \"devmod:nummodules\" 01 # unsigned(1) 82 # array(2) - ServiceInfo Key-Value Pair 3 6E # text(14) 6465766D6F643A6D6F64756C6573 # \"devmod:modules\" 83 # array(3) 01 # unsigned(1) - Module Index 01 # unsigned(1) - Number of modules 67 # text(7) 66646F5F737973 # \"fdo_sys\" OwnerServiceInfo \u00b6 fdo_sys:active \u00b6 Diagnostic Notation (not used by protocol) [true, false, [[[\"fdo_sys:active\", true]]]] CBOR 83 # array(3) F5 # primitive(21) - IsMoreSeviceInfo F4 # primitive(20) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 6E # text(14) 66646F5F7379733A616374697665 # \"fdo_sys:active\" F5 # primitive(21) fdo_sys:filedesc \u00b6 Diagnostic Notation (not used by protocol) [true, false, [[[\"fdo_sys:filedesc\", \"startup.bat\"]]]] CBOR 83 # array(3) F5 # primitive(21) - IsMoreSeviceInfo F4 # primitive(20) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 70 # text(16) 66646F5F7379733A66696C6564657363 # \"fdo_sys:filedesc\" 6B # text(11) 737461727475702E626174 # \"startup.bat\" fdo_sys:write \u00b6 Diagnostic Notation (not used by protocol) [true, false, [[[\"fdo_sys:write\", h'4045\u2026']]]] CBOR 83 # array(3) F5 # primitive(21) - IsMoreSeviceInfo F4 # primitive(20) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 6D # text(13) 66646F5F7379733A7772697465 # \"fdo_sys:write\" 59 0116 # bytes(278) 4045.. # \"@E\" -rest of 278 byte file fdo_sys:exec \u00b6 Diagnostic Notation (not used by protocol) [false, true, [[[\"fdo_sys:exec\", [\"cmd\", \"/c\", \"startup.bat\"]]]] CBOR 83 # array(3) F4 # primitive(20) - IsMoreSeviceInfo F5 # primitive(21) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 6C # text(12) 66646F5F7379733A65786563 # \"fdo_sys:exec\" 83 # array(3) 63 # text(3) 636D64 # \"cmd\" 62 # text(2) 2F63 # \"/c\" 6B # text(11) 737461727475702E626174 # \"startup.bat\" ismore flag \u00b6 The 'ismore' more should be true is if the message being sent is not a complete processable message. All fdo_sys messages are complete messages, so the 'ismore' flag will always be true in this case.","title":"ServiceInfo System Module"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_sys-module-definition","text":"The system module defines basic onboarding operations such as downloading content and executing commands. The following table describes key-value pairs for the system module. Key Name Value Meaning fdo_sys:active CBOR Bool True to activate the fdo_sys module. fdo_sys:exec CBOR Array of String values The command is put as array elements. The command performs a system call. fdo_sys:filedesc CBOR String Describes a path to a file that will be used in subsequent file operations. fdo_sys:write CBOR BSTR Appends a block of data to the current file description.","title":"fdo_sys Module Definition"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_sysexec-message","text":"The fdo_sys:exec command performs a system call on the device. The value of this command is a CBOR Array of String values. The first string in the array is the command to execute and the remaining strings are the arguments to the command. It is expected that it would use \u201cexec\u201d (system call) or similar API to execute the command on the device. JSON* (readable description) [\"/bin/sh\",\"startup.sh\"] CBOR 82 # array(2) 67 # text(7) 2F62696E2F7368 # \"/bin/sh\" 6A # text(10) 737461727475702E7368 # \"startup.sh\" C example execvp(\u201c/bin/sh\u201d,(char* []) {\u201cshartup.sh\u201d})","title":"fdo_sys:exec Message"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_sysfiledesc-message","text":"The fdo_sys:filedesc message describes the path to a file the will be used as a part of the onboarding process. A zero-length file is expected to exist on the local file system after this command is received. If the described file already exists, it is truncated to zero length, otherwise a zero-length file is created. The permissions for the created file is set to read/write for the user account the module is running under. File permissions can subsequently be modified with the fdo_sys:exec command if needed. If a path is not included as a part of the file name, the file is created under current working directory of the module. All subsequent fdo_sys:write operations will append to this file. If another fdo_sys:filedesc message is received, all subsequent fdo_sys:write messages will start appending to the file specified by the fdo_sys:filedesc message.","title":"fdo_sys:filedesc Message"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_syswrite-message","text":"The fdo_sys:write message provides an array of bytes that gets appended to the file described by the last fdo_sys:filedesc message. If this message is sent without being preceded by fdo_sys:filedesc, then a message 255: INVALID_MESSAGE_ERROR will be thrown and TO2 will not be completed. Once a fdo_sys:filedesc message has been received, many fdo_sys:write messages can follow.","title":"fdo_sys:write Message"},{"location":"implementation-references/serviceinfo-sys-module/#examples","text":"Below are examples of the fdo_sys messages encoded as CBOR. The JSON examples are just human readable definitions while the actual messages are always CBOR. The encoding includes the entire TO2.OwnerServiceInfo message includes the isMore and isDone flags. Device should advertise it supports fdo_sys. NOTE : This example just includes the module list key value pairs and not all the required values for the devmod.","title":"Examples"},{"location":"implementation-references/serviceinfo-sys-module/#deviceserviceinfo-devmod","text":"Diagnostic Notation (not used by protocol) [false, [[[\"devmod:active\", \"true\"], [\"devmod:nummodules\", 1], [\"devmod:modules\", [1, 1, \"fdo_sys\"]]]]] CBOR 82 # array(2) F4 # primitive(20) - IsMoreSeviceInfo 81 # array(1) - ServiceInfo 83 # array(3) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 1 6D # text(13) 6465766D6F643A616374697665 # \"devmod:active\" 64 # text(4) 74727565 # \"true\" 82 # array(2) - ServiceInfo Key-Value Pair 2 71 # text(17) 6465766D6F643A6E756D6D6F64756C6573 # \"devmod:nummodules\" 01 # unsigned(1) 82 # array(2) - ServiceInfo Key-Value Pair 3 6E # text(14) 6465766D6F643A6D6F64756C6573 # \"devmod:modules\" 83 # array(3) 01 # unsigned(1) - Module Index 01 # unsigned(1) - Number of modules 67 # text(7) 66646F5F737973 # \"fdo_sys\"","title":"DeviceServiceInfo (devmod)"},{"location":"implementation-references/serviceinfo-sys-module/#ownerserviceinfo","text":"","title":"OwnerServiceInfo"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_sysactive","text":"Diagnostic Notation (not used by protocol) [true, false, [[[\"fdo_sys:active\", true]]]] CBOR 83 # array(3) F5 # primitive(21) - IsMoreSeviceInfo F4 # primitive(20) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 6E # text(14) 66646F5F7379733A616374697665 # \"fdo_sys:active\" F5 # primitive(21)","title":"fdo_sys:active"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_sysfiledesc","text":"Diagnostic Notation (not used by protocol) [true, false, [[[\"fdo_sys:filedesc\", \"startup.bat\"]]]] CBOR 83 # array(3) F5 # primitive(21) - IsMoreSeviceInfo F4 # primitive(20) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 70 # text(16) 66646F5F7379733A66696C6564657363 # \"fdo_sys:filedesc\" 6B # text(11) 737461727475702E626174 # \"startup.bat\"","title":"fdo_sys:filedesc"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_syswrite","text":"Diagnostic Notation (not used by protocol) [true, false, [[[\"fdo_sys:write\", h'4045\u2026']]]] CBOR 83 # array(3) F5 # primitive(21) - IsMoreSeviceInfo F4 # primitive(20) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 6D # text(13) 66646F5F7379733A7772697465 # \"fdo_sys:write\" 59 0116 # bytes(278) 4045.. # \"@E\" -rest of 278 byte file","title":"fdo_sys:write"},{"location":"implementation-references/serviceinfo-sys-module/#fdo_sysexec","text":"Diagnostic Notation (not used by protocol) [false, true, [[[\"fdo_sys:exec\", [\"cmd\", \"/c\", \"startup.bat\"]]]] CBOR 83 # array(3) F4 # primitive(20) - IsMoreSeviceInfo F5 # primitive(21) - IsDone 81 # array(1) - ServiceInfo 81 # array(1) - ServiceInfo Key-Value Array 82 # array(2) - ServiceInfo Key-Value Pair 6C # text(12) 66646F5F7379733A65786563 # \"fdo_sys:exec\" 83 # array(3) 63 # text(3) 636D64 # \"cmd\" 62 # text(2) 2F63 # \"/c\" 6B # text(11) 737461727475702E626174 # \"startup.bat\"","title":"fdo_sys:exec"},{"location":"implementation-references/serviceinfo-sys-module/#ismore-flag","text":"The 'ismore' more should be true is if the message being sent is not a complete processable message. All fdo_sys messages are complete messages, so the 'ismore' flag will always be true in this case.","title":"ismore flag"},{"location":"pri/pri-introduction/","text":"Protocol Reference Implementation Introduction \u00b6 The Protocol Reference Implementation README provides a quick start guide for building and running the FIDO Device Onboard Protocol Reference Implementation.","title":"Protocol Reference Implementation"},{"location":"pri/pri-introduction/#protocol-reference-implementation-introduction","text":"The Protocol Reference Implementation README provides a quick start guide for building and running the FIDO Device Onboard Protocol Reference Implementation.","title":"Protocol Reference Implementation Introduction"}]}